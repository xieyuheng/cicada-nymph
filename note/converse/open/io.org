* 題解
  * 輸入與輸出
* 討論 <2015-06-16>
  - x ::
       我們現在需要重新設計 IO 了
       之前根本沒有設計好
       都是爲了快速實現所需要的性狀
       現在基本的性狀都實現了
       可以回來優化這裏的設計了
       這次需要注意錯誤處理
  - k ::
       相比之
       前現在有下列新性狀可用
    1. 用 (await) 和 (awake) 做非局部退出
    2. 匿名函數
    3. (allocate-conjugate-local-memory)
  - x ::
       也許現在應該用處理代碼生成的問題了
       因爲爲系統的數據結構定義接口非常枯燥
       我們可以模仿 org-mode 中的表格來設計語法
  - k ::
       那將是可讀性非常高的語法
  - x ::
       但是我發現回顧之前的並沒有錯誤的代碼
       是一件非常令人不情願的事
       我想 我們必須把目標更具體化
       最好能夠想出一些新的性狀在代碼回顧過程中實現
       否則就太枯燥了
  -----------------------------
  - x ::
       關於 錯誤處理
       有各種形式
    1. 函數正常返回 返回出錯信號
    2. 假設錯誤是不可原諒的
       函數打印出錯信息
       此時需要考錄返回什麼值
    3. 錯誤是可以原諒的
       調用 awake 做非局部退出
       我的處理方式是
       關於 <port> 使用第一種
       關於 <file> 和 <directory> 使用第二種
       也就是說
       在調用 <file> 和 <directory> 中的處理函數時
       需要事先用 <file> 和 <directory> 相關的謂詞
       來保證可以成功調用
  - k ::
       也就是說
       雖然現在有 await 和 awake 了
       但是還是不使用它們
  - x ::
       都是爲了簡化接口
       並且
       我先不考慮代碼生成
       試試手寫接口函數的效果如何
       哦
       我發現我必須先考慮代碼生成
       這在於 定義接口的時候需要 offset
       我不想要手動計算這個 offset
       在之前的處理中
       使用的不是 "代碼生成" 而是 "offset 生成"
       也就是在運行時我能通過遞增一個全局變量
       來 指明 size 而 生成 offset
       但是在手動定義接口的時候
       是沒法取得全局變量的值的
       所以這裏必須使用代碼生成
       其實只有兩個數據結構
       一個是 getdents64
       一個是 stat
       我實現代碼生成機制
       然後用這兩個數據結構來做測試
       然後再儘量把代碼生成機制應用到更多的地方
  -----------------------------
