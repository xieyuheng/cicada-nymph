#+TITLE:  蟬語記 / cicada language note
#+AUTHOR: 謝宇恆 / XIE Yuheng
#+EMAIL:  xyheme@gmail.com

* 姓名
** 意義
   * 每一物必有一姓
     物以姓爲類
     一姓一名可命於一物
     所命姓名之姓
     不必與物之本姓相同
** 實現方法
   * 方法一
     * 爲了形成姓名這兩個層次
       一字符串之散列表以存名
       一名之表以爲姓
** 姓之爲類型 用以分類函數
   * 姓之首要運用在於
     作爲結構化的數據的類型編碼
     之後
     就能形成對一羣複雜的函數的分類與命名
     這在與
     每作一函數
     必爲[常爲]處理某些數據
     而數據階有類型 姓即爲其類型之編碼
     當需要給函數賦以姓名時
     擇其所作用諸物之主要者
     使函數之姓從之
     再取名即可
     這樣依姓而分函數爲類
     就讓人對一羣複雜的函數有了更好的理解
   * 某一數據類型的處理函數可能需要
     1. 初始化函數
     2. 等詞
     3. 問詢結構化數據的性質的函數
** [否決] 數學結構
   我知道某些語言中
   有試圖捕捉數學結構這個概念的嘗試
   不管是用 type 還是用 module
   沒有一個不流於對數學的拙劣模仿
   所以我放棄這種嘗試
   而強調在這方面數學語言與程序語言的差異
** >< 姓之爲語境 用以分類語法關鍵詞
   * 一個語境是一個姓
     我用這個概念來解決
     1. 語法關鍵詞之間的集體相互調用問題
        [因爲 它們之間有很多相互遞歸調用]
        這在於
        * 一個姓就代表一個語境
        * 每一個個語法關鍵詞
          在聲明其所要[遞歸]相互調用的其他語法關鍵詞的時候
          將不逐個聲明 而以語境爲單位
        * 並且
          我提供語義 以使得 在聲明所要遞歸調用的語境時
          能夠局部覆蓋其中的某個語法關鍵詞
          或者局部增加 等等
     2. 語法關鍵詞的重載問題
        這在於
        同一個語法關鍵詞在不同的語境下的意義可以不同
   * 在編譯器運行的每個時刻
     不是 在某個語境中
     而是 在某個語法關鍵詞的控制之下
     而這個語法關鍵詞 一定屬於某個語境
   * 在不同的語法關鍵詞的控制下
     讀取字符串的方式不同
     有的 一詞一詞的讀
     有的 一字一字的讀
     有的 認爲某些 bar-ket 爲特殊
   * "自治性" 的意思就是說
     每個語法關鍵詞都要從最底層的字符串處理寫起
     語法關鍵詞是那些一定在[常常在]編譯期被調用的函數
     它們統一[至少]以
     被編譯的[帶有光標的][也可能帶有其他元數據的]字符串
     爲隱含的參數
     在讀字符串並移動光標的過程中
     它們會編譯各種數據各個數據域
   * 這種設計看似很底層
     但是其實只要實現好
     相對應於各種對字符串的讀取方式的幫助函數
     [也就是做好 對函數的因子分解]
     那麼就能從橫向控制複雜性
     而不是去形成不同的處理層次
     [兩種控制複雜性的思路之間並沒有優劣之分]
   * 注意
     每個語境下除了要有 被空格分割的 語法關鍵詞之外
     還需要有別的 處理機制
     比如
     1 2 (add) = 1 (add 2) = (add 1 2)
     (arg2:> 2)
     2#1100_0110
     這些時候 需要的謂詞是非平凡的
     [也就是說 對其他的語法關鍵詞的出現的判斷是平凡的]
** 語法不重要
   * 有了語境的概念之後
     語法就應該能夠被靈活地改變了
     所以語法就不重要了
   * 所以對於所設計的某個語義
     不必在語法的設計決策上 耗費過多的時間
     因爲
     要知道
     當發現所設計的語法不好用時
     可以隨時更換設計
** 姓之爲區 用以形成相對的地址
   * 每個地址都是相對某個區而言的
** 姓之爲結構
** 姓之爲模塊
* 約束變元
** 語義
   * 就是用一種標記語言 來標記出函數體中的位置
     然後再函數作用時 把值代入到這些位置
** 遞歸調用
   * 如果一個函數遞歸調用了自身
     那麼在遞歸調用時
     這個函數的作用還沒有結束
     所以
     函數的作用過程中
     其約束變元的值不能真的被代入到
     約束變元所標記的
     函數體中的位置中
     因爲否則
     對這個函數的遞歸調用
     就會更新這個這個位置下的值
   * 所以
     用一個分離的約束變元棧
     來保存函數作用過程中所獲得的
     約束變元的值
     而函數體內約束變元的位置上
     保存 到這個棧中的 offset
** 明顯的參數
   * 明顯的參數所提供的額外信息
     只被用來重排參數的順序而已
   * 可以[應該]有更多的用處嗎
   * 明顯的參數作爲一個 特殊的 name
     出現在參數棧中就行了
* 函數體內的結構化數據
** 函數能夠返回函數
   * 如果
     外層的函數的作用會返回一個內層的函數
     並且
     內層的函數中包含了
     由外層的函數所綁定的約束變元
     [ .x [ :x ] .y ]
     那麼
     當外層的函數的作用結束之後
     內層的函數中所包含的
     由外層的函數所綁定的約束變元
     必須還具有形成綁定時的值
   * 簡單的解法有兩種
     1. 每個函數都是 函數體+名與值的綁定的鏈表
     2. 返回一個內層函數的複製
        並且在複製的同時把約束變元的值
        真正地代入到約束變元所標記的
        內層函數的函數體中的位置當中
   * 傳統的 scheme 實現使用第一種解法
     而我使用第二種解法
     只爲嘗試一些新的想法而已
   * 這種解法下
     1. [缺點]
        函數不是 閉包[closure]
        而 當把函數處理成 閉包 時
        每個函數都是 函數體+名與值的綁定的鏈表
        如果有兩個函數僅僅是 對名的綁定不同
        那麼這兩個函數就可以重用一個函數體
        而使用不同的對名的綁定
        而在我所選擇的處理方式下
        不能重用 函數體
        這樣就浪費了內存
     2. [缺點]
        當返回很大的函數體時
        複製其函數體的過程會很浪費時間
     3. [缺點]
        參數不足時的函數作用
        不能被看作一種函數返回函數的特殊情況
        來以一致的方式處理
     4. [優點]
        而在每個函數作用的時候
        因爲其中約束變元的值已經被代入了
        所以將在此處節省時間
     5. [優點]
        因爲函數體不被 不同的 名與值的綁定的鏈表 共用
        所以可以對函數體作副作用
        從觀念上看
        可以認爲函數的實體性更強了
** 函數返回對結構化的數據的複製
   * 進一步而言
     每當一個函數需要返回一個結構化的數據之時
     [比如 無名的函數]
     都需要能夠返回這個結構化的數據的複製
     [我可以提供明顯的語法以聲明對複製的需要與否]
     並且當被複製的結構化的數據中
     包含由這個函數所綁定的約束變元的時候
     這個約束變元的值
     會在複製函數遍歷結構化的數據的同時
     被代入到其位置之中
   * 注意
     複製結構化的數據的時候
     其 所申請的內存的種類[比如 是否需要 GC]
     其 在 雙向鏈表 單向鏈表 向量 這三種數據結構之間的轉換
     都可能需要相關的語法來聲明
** 複製中的圈狀引用
   * 當複製一個結構化的數據的時候
     我要求其中的所有的 圈狀引用 都能夠被探測並保留
   * 這是一個非常難以高效實現的性狀
     複製壓縮性的 GC 算法中所使用的技術
     可能夠在這裏重用
** 參數不足時的函數作用
   * 如果使用 閉包
     那麼就能以一致的方式
     處理這種 返回函數的函數 的特殊情況
     也就是將所有的多元函數都 一元化[curry]
   * 如果不使用 閉包
     而返回函數體的複製
     那麼所使用的算法就將面臨其最惡劣的情況
     所以
     我還是要使用閉包
   * 要麼返回複製
     要麼返回閉包
     我提供不同的處理方式以供選擇
   * 當然
     對各種情況我也會設計合理的默認處理方式
   * 如果不提供 複製與閉包之間的選擇的話
     我可以把 參數不足時的函數作用 統一處理成 閉包
     而把 內部返回的函數處理成 複製
     這樣就限制了閉包的層次
     使得做多隻有一層閉包
** [否決] 變長的棧中的值
   * 對變長值的需要在於
     這樣就可以在沒有 GC 的時候實現閉包了
     因爲對於閉包而言
     名與值的綁定的鏈表
     需要用 GC 來實現
   * 就像複雜指令集中的變長指令一樣
     如果我允許變長指令的話
     棧的接口就要在時間複雜度上增加一個常數了
     還由於
     複雜的接口會讓 primitive-function 也變複雜
   * 所以我放棄這種計
* 編譯
** 本質
   * 編譯的本質是
     化人可識之名
     爲機器可以處理之數
** 姓的尋找
   * 基本的原理是
   * 所給予編譯器的信息 可以只是函數的名
   * 對與函數的姓
     將可以從
     在之前被編譯到函數體內的
     數據的姓中推斷出來
   * 當在編譯時期 沒法推斷出來姓的時候
     就編譯一個 用來在運行時期
     將 棧中的數據的姓
     與 函數體中被調用的函數的名
     進行匹配的 動態處理函數 進函數體中
     並且把需要處理的函數名也編譯到函數體中
   * 這樣就能夠達到對函數名的重載的效果
** 提前作用
   * 首先要注意某些輸入輸出類型的副作用函數
     不能被提前作用
   * 是否讓 提前作用 也自治呢
     自治的好處在於靈活
     而壞處在於語法可能複雜
     但是 因爲有語境這個概念的幫助
     所以 可能自治並不會語法變得太複雜
   * 在推斷出了函數的姓的時候
     關於函數作用的時機
     基本的原則是
   * 儘可能在編譯時期處理更多的函數作用
     並且視這種編譯期的處理爲對運行時效率的優化
   * 唯一的不能進行提前作用的情況是 參數不齊全
     如果保證在處理每次函數作用的時候
     都在是參數補全的時候才放棄優化
     那麼就能達到一種理論上的最優
   * 如果
     儘管 參數不全
     但是 但是某些約束變元已經可以用來綁定了
     那麼這時也許可以進行一些特殊的處理
     以避免完全運行時的對約束變元的處理
   * 但是如果對約束變元的處理是
     將約束變元的值入約束變元棧
     那麼
     這種處理就只能運行時來進行了
** 找姓的原則
   * 編譯器在找姓時所用的機制
     就決定了在省略姓時
     函數作用所能出現的形態
   * 我的設計是
     從第一個的參數的姓
   * 要知道如果有歧義總可以加上姓
   * 如果需要動態性
     則我提供明顯的方式以聲明姓之所從之位置
   * 性狀是
     如果函數與其兩個參數同姓
     那麼跟其二者之任一階可
     [如果用預先指定等等複雜的機制 就將沒有這個性狀]
   * 每次找到姓之後
     都會匹配參數的名
     作爲檢查
** 有默認值的參數
   * 有默認值的一定是有名參數
     有默認值的有名參數 和 一般的有名參數不同類
     因爲 我希望某些參數 在被省略時 能夠自動形成 curry
     而 有初始值的參數 在被省略時 就以其默認值爲參數
   * 有初始值的參數 其實就是這個函數的局部變元
     只不過當把這種特性按照 具有初始值的參數來實現的時候
     就提供了接口來改變這些函數的局部變元
** 對姓已經找好的編譯好的函數作用
   * 此時看的是棧中的值
     而不再是函數體中前面的值
   * 此時函數處理參數的方式
     就決定了參數在棧中的排佈格式
   * 條件是
     1. 完全省略參數名是允許的
        此時會按約定的順序來處理
     2. 約定的順序可以以明顯的方式聲明
        也可以在定義函數時
        根據函數體的幾何而自動生成
        [當然這些是構造函數時的事]
   * 函數可以被分爲很多類
     比如
     1. 函數完全使用有名的約束變元
     2. 函數完全使用無名的約束變元
     3. 函數使用了兩者
   * 我的設計是[別的設計方式也是可以想像的]
     要求
     所有的有名的約束變元
     必須出現在棧的頂端[即使在省略名時]
     此時
     用有名參數的個數
     去查看棧中參數的命名情況
     有名者依名無名者依序 即可
   * 這樣的特點是
     當參數的順序排佈正確是
     就可以隨時給某個位置的函數添加或省略參數名
   * 注意
     有名參數是可以有默認值的
     我把有默認值的參數另立一類來處理
     我要有初始值的參數不能出現在無名的局部變元之後
     它們的出現將不被計算爲有名的參數
** 逆
   * 我需要讓我的編譯器具有良好的反編譯的能力
     爲此
     首先
     我需要在函數體中保存的就是
     這個函數被綁定到的姓名
   * 難點在於
     如果我允許一個函數體被綁定到多個姓名
     那麼
     就需要用鏈表來實現這裏的數據結構了
   * 在每個函數體內還需要編碼它對約束變元的使用情況
     這裏可以限制約束變元的姓
     也可以不限制
** 初期的函數 是 指令所組成的向量
   * 一個 向量函數
     是一個指令所組成的向量
     附加一些元信息
     元信息中
     靜態的部分用向量實現
     動態的部分用鏈表實現[鏈表所分配的數據區域還不確定]
** 由小組大
   * 所能使用的抽象方式幾乎就只是函數而已
     由小的函數組成大的函數的方式是
     複合 與 作用
     但是只要我保持使用 姓 的方式的靈活性
     那麼我就能夠模仿
   * 比如
     繼承[遺傳] 與 變異
     這在於
     在製造新的東西的時候
     利用已經製造過了的類似的東西
     具體地
     1. 可以 複製別人的處理函數過來
        並對其作一些修改
        尤其是 初始化函數可能需要這種方式的變異
        尤其是 關於函數類型的數據也需要改寫
     2. 也可以 直接聲明重用別人的處理函數
        既然我已經決定要用多種數據結構來實現函數體了
        那麼此時我就也應該能選擇
        在複製函數體的時候
        使用那種數據類型
     3. 也可以 不作複製
        而以別的處理函數爲基礎 複合一個新的函數出來
** 嫁接機制
   * 當聲明需要 抓取計算的時候
     用來實現函數作用接口的 三個 stack
     都要從 vector 轉變爲 list
   * 所以對計算的抓取是要使用明顯的語法來聲明的
     當不要抓取的時候再聲明
     以轉會 vector
** 基本的定義函數的語法
   * 關念上
     應該是先生成一個無名函數
     然後給這個無名函數綁定一個名字
   * 這種無名函數的作用可以是
     形成無名的幫助函數
   * 對無名函數所處的區需要聲明
     這決定了是否用到GC
* 類型
** 類型檢查
   * 類型檢查 類似於 提前作用
     只不過 因爲 約束變元的出現
     而使得無法直接使用值來做提前作用
     故
     轉而 使用類型來做提前作用
   * 所謂 type constructor
     就是類似 "type -> type" 和 "[type]" 的東西
     它們都是爲了使得對類型的計算能夠進行下去的機制而已
     我並不在乎這些機制
     我只要把對類型的計算進行下去就行了
** [否決] 類型推導
   * 類型推導 在於
     利用函數的類型來推導約束變元的類型
     要知道
     爲了進行 類型檢查
     所有的約束變元都是要有類型的
     這樣就導致了在我的設計中沒法使用類型推導
     因爲 我是從值來推導函數的 而不是相反
** 每個約束變元都有類型[姓]
   * 約束變元這個名字翻譯自英文的 bound-variable
     其意義爲
     這個 變元[名字] 的意義
     [具體的在程序語言中 這個意義就是 名與值之間的綁定]
     是被約束在某個區域[語境]之內的
     出了這個區域之後 其意義就改變了
     其特點是
     變元名字的選取是任意的
     它的目的只是爲了標記區域中的位置
   * 無名的約束變元
     argument-stack for unnamed-local-variable
   * 有名的約束變元
     frame-stack for named-local-variable
   * 函數體內應該保存其約束變元[還有返回值]的類型信息
     其用性自名 不做分說
   * 保存約束變元信息的地方是函數的頭
     而不是每個約束變元所標記的位置
   * primitive-function 和 vector-function
     都需要相關的類型信息
     但是其實現方式不同
     所以 這裏就需要保持其接口設計的一致
** 複雜的類型的編碼
   * 類型之間就必須能夠相互嵌套了
     因此就沒法用 姓 來簡單的給類型編碼了
     必須使用別的數據結構
   * 注意
     編碼的目的是讓對類型的計算能夠進行下去
   * 既然已經決定講GC實現在VM中了
     那麼我就能設計好這些數據結構了
   * 使用 複姓 的概念
     每個複姓還是有一個主姓的
     比如 list number
   * 自治性
* 鏈表處理
  * 不應該使用 pair 來實現 list 這個數據結構
    因爲這樣每個 list 中需要保存很多多餘的類型信息
  * 可以說 lisp 對 list 的認識是侷限性非常強的
    而熟悉 lisp 者 常常不自知
* 註釋的格式
  * 在之前 對棧的操作的註釋是被忽略的
    也就是說
    編碼者 辛辛苦苦鍵入的信息被愚蠢的機器忽略了
    我現在就設計新的 註釋的格式 來修正這一錯誤
  * 要求這個 註 中所能包含的信息有
    1. 副作用 類型
       包括 編譯到內存的信息
    2. 還有輸入輸出信息等等
       仔細想像 副作用的類型其實 十分有限
       這些信息必須足以讓 詞典編撰者 推導出
       這個函數的作用能否在編譯時期被處理
       如果這裏有困難
       那就直接把 這個性質變成一個明顯的聲明好了
* 文庫
  * 美 代碼的集合 之名曰 文庫
  * 包含完整的工具鏈
  * 用於指定編譯和加載代碼順序的格式用 org-mode 寫成
    其處理的也是 org-mode file
    規定了如何 編織 編譯 和 加載
  * 跟所謂文學編程相關的
    有 publish 函數
    對應於 每個 org 文件
    還要有相應的 描述其樣式的 style 文件
    然後才能 publish
* 嫁接機制 與 多種類型的函數體
** 一種優化
   * 這是一種優化
     這在於
   * 就遍歷速度而言
     用數組所實現的函數體
     快於
     用鏈表所實現的函數體
   * 就內存分配速度而言
     用數組所實現的參數棧和返回棧
     快於
     用鏈表所實現的參數棧和返回棧
   * 所以雖然GC在VM中
     但是嫁接機制也不能被廢止
** 嫁接機制
   * 用鏈表來實現的參數棧和返回棧
     就能實現 對計算的抓取 這一性狀
   * 參數棧和返回棧 的 嫁接機制
     使得可以
     在需要 對計算的抓取 時
     用鏈表來實現參數棧和返回棧
     在不需要 對計算的抓取 時
     用數組來實現參數棧和返回棧
     二者相互嫁接
** 多種類型的函數體
   * 我提供明顯的語法
     使得用戶能夠聲明
     1. 使用數組還是鏈表來實現函數體
     2. 把函數體以靜態的形式儲存到內存中
        還是
        把函數體以動態的形式儲存到
        被垃圾回收器所處理的內存中
* 數據分配器
** 正名
   * 我不使用 垃圾回收器 這個術語
     而 使用 數據分配器[data-giver] 這個術語
   * 這在於
     前者是消極的短語
     後者是積極的短語
   * 並且
     可以被重複利用的 內存空間 如何被發現[所謂垃圾回收]
     其實並不是用戶所關心的
     用戶所關心的是
     在需要的時候 用來實現數據結構的 內存空間如何被分配於用戶
     關於 "分配" 的函數
     纔是這類動態內存管理系統的接口
     而關於 "回收" 的函數不是
** 標記 式 數據分配器
   1. 一個數組被作爲 數據分配器 的對象
      數組之元素被稱爲 點
   2. 點 之間有一個離散的全序關係
      點的集合形成一個離散的一維線性空間
   3. 每個 點 中有 某些 域
      可以用來存儲數據
      通過在一個點的 域 中保存其他點的地址
      點與點之間就能形成聯繫
      點的全體 與 它們之間的關係 就是一個有向圖
      [這個有向圖是受某些性質限制的]
      [比如每個點所發出的有向邊只能有有限條]
      [即 有限叉有向圖]
   4. 數據分配器
      的唯一職責是給用戶分配 點
      唯一接口是 cons 這個函數
      所需要達到的效果是
      給人以有無限個 點 可以被使用的假象
   5. 標記 式 數據分配器
      產生這種假象的方式是
      首先它順着 一維離散空間 取 點
      當取完之後
      某些被用戶用過的點
      現在就又可以被重新使用了
      此時只要能夠判斷出
      那些點是可以被[安全地]重新使用的就行了
   6. 那個靜態的 長度固定的 一維數組
      提示着我們需要去給 數據分配器 一個 工作週期 的概念
      一個工作週期的開始和結束都是在
      cons 把 空間中最後一個點返回之後
      [當然 除了第一個工作週期之外]
   7. 有三個部分 相互配合 來完成工作
      它們分別是
      marking finding cleaning
      其中 cleaning 的工作是伴隨 finding 而進行的
   8. marking
      標記出下一個週期中將被認爲是不自由的點
      在下一個週期中 這些點 將不能被 finding 找到
   9. 也就是說 每個點上面需要有一個[一些]可以用來進行標記的域
      有三個這樣的域
      分別爲 marking域 finding域 cleaning域
   10. finding
       利用了 離散一位線性空間的全序關係
       也就是說 找下一個點的時候會順着這個序關係來找
       沒有被上一個週期的 marking 標記爲 "將不能被 finding 找到" 的點
       就是在需要返回一個點的時候 能夠被 finding 使用的點
   11. 需要定義 什麼是 "將不能被 finding 找到" 的
       定義 "在下一個週期中將不能被 finding 找到的點"
       即 "在下一個週期中還能夠以被引用到的點"
       而 "一個點 能夠以被引用到"
       被定義爲 "從根節點出發沿有向圖的有向邊能夠走到這個點"
       而 "根節點就所有全局變量和局部變量[即參數棧]"
   12. 每當一個點被賦值給全局變量的時候
       或一個點被賦值給一個已知是能夠被引用到的點的時候
       那麼在進入下一個週期的時候
       這個點就有可能是 能夠被引用到的點
       也有可能是不能被用到的
       [考慮一些使從根節點出發的有向路斷裂的副作用就知道了]
       但是重要的性質在於
       如果讓 marking 去標記所有這些可能是 能夠被引用到的點
       那麼所有 能夠被引用到的點 一定就都被標記了
       並且還可能有很多 其實並不是 能夠被引用到的點 也被標記了
       這個性質確保了 數據分配器 的正確性
   13. 如果 在一個工作週期結束的時候 啓動 marking
       那麼它就會從根節點出發
       去進行一個有向圖的深度有限的遍歷
       從而把所有的 能夠被引用到的點 都標記出來
       在下一個工作週期開始時
       所有 marking域 沒有被標記的點
       就是可以被 finding 找到的點
   14. 而 數據分配器 的漸進性在於
       不必讓 marking 在工作週期結束之時才開始工作
       只要保證它在 在工作週期結束之時才完成工作
       就可以了
       所以它可以時不時地去做一些標記工作
       然後休息一會兒
       只要它記住在遍歷有向圖的路程中自己已經走到哪個地方了
       就行了
       [當然每當需要做這種記憶的時候其實就是需要一個棧而已]
   15. 每個點中分別有 爲 marking finding cleaning 而準備的三個域
       每個工作週期結束的時候 三個域會進行一個置換
       所進行的置換 將是三階置換羣中的兩個三循環置換之一
       具體情況如下
       1) 本次 工作週期中的 marking域 所標記好的域
          是給 下一個工作週期的 finding域 使用的
       2) 隨着 finding 遍歷 整個一維離散線性空間
          cleaning 在本次工作週期結束的時候 清空所有點的 cleaning域
          而 本次 工作週期中的 cleaning域
          是給 下一個工作週期的 marking域 用的
          在下個工作週期開始
          marking 所得到的應該是被清空的 域
       3) 本次 工作週期中的 finding域
          在本次工作週期結束之後 其使命就結束了
          它們 將會作爲下一個工作週期 cleaning域
   16. marking 和 finding 的工作是相互獨立的
   17. 這種以 標記而形成的反證法
       來證明那些 那些點在下一個週期可以被使用的
       的方式
       決定了 finding 必須要有一個
       "檢查標記" 以尋找沒有被標記的點的 尋找過程
       這個過程必須 跑遍整個離散線性空間
       從而使得理論上的時間複雜度變大了
** 標記 式 數據分配器 對與 所佔空間大小不確定的數據 的分配
   1. 可以用壓縮式的垃圾回收器來實現對字符串的動態內存管理
      因爲 string 的長度可變
      所以簡單的 marking-gc 是不適用的
   2. 其實單就這一個技術上的不一致之處
      就足以說明 標記 式 數據分配器 是不可取的了
      因爲
      這種設計上的不一致性 將會給維護和擴展帶來很大麻煩
      並且很多意想不到的技術問題可能隨時冒出來
      這都是因爲對於 沒有一致性的設計
      人們很難形成良好的理解所致
   3. 在 marking 工作的時候 如果看見 <string>
      就更改引用點 並且複製字符串
      [makeing 是知道引用點是哪個的]
   4. 如果 string 的堆比 pair 的堆先耗盡
      這時就必須重啓 gc
      所以應該把 string 的堆設置的充分大 以避免這種情況
** 標記 式 數據分配器 的缺點
   1. 其時間複雜度在理論上劣於
      複製-壓縮 式 數據分配器
   2. 有可能影響漸進性的情況是
      finding 遲遲找不到一個沒有被標記的點
      當有很多的被標記的點 充斥着那個一維離散線性空間時
      這種情況會經常發生
   3. 沒法以一致的方式處理
      所佔空間大小不確定的數據
      即 此時又必須用到 複製-壓縮 式 數據分配器
** 標記 式 數據分配器 的合理性
   1. 如果要求
      所佔空間大小不確定的數據 之間不能形成複雜的相互引用
      那麼 這種處理方式
      就避免了 複製-壓縮 式 數據分配器
      在處理這種 情況時所將會遇到的困難
      即 "更新困難"
   2. 注意
      這種 "更新困難"
      只有當要求 數據分配器 的漸進性的時候纔會發生
** 複製-壓縮 式 數據分配器
   * 這種類型的 數據分配器 只專注於 所能夠被引用到的點
     而不理會不能被引用到的點
     [它摒除了 標記 式 數據分配器 中的 finding]
   * 用一個深度優先的遍歷就可以了
   * 注意
     每當把一個 cons 從一個 heap 複製到另一個 heap
     所有引用這個 cons 的 cons 都需要被更新
     這就是所謂的 "更新困難"
     這確實是一個困難
     因爲所要達到的特性是
     每當從一個工作週期進入下一個工作週期當中時
     所有能夠被引用到的結構化的數據的地址都必須被置換
     從一個 堆 變到 另一個堆
     被數據分配器所管理起來的結構化的數據越多
     那麼去對它們進行正確的更新也就越難
   * 在每個 cons 中有兩個域爲數據分配器而設計
     一爲 標記域 以標記數否被複製過
     一爲 新地址域 以記錄被複製到的新地址
     [每個 cons 作爲數據結構還需要更豐富一點 是一個定長數組]
   * 三染色算法 的施行
     其實是與數據分配器的如上兩種分類沒有關係的
     其主旨是記錄一個工作週期中
     工作完成的進度
   * 可不可以這樣
     在做標記的同時 也做 copy
     但是我並不急着使用 被 copy 好的數據
     而只有當 第一個 離散線性空間被耗盡了的時候
     才轉而去 使用被 copy 好的數據
   * 只要讓每個根結點中
     有兩個域用來保存結構化的數據
     並且交替使用這連個域就可以了
     [對根結點作爲數據結構的設計就要小心了]
   * 對比
     1. 遍歷所有點 才能找到下一個自由點
     2. 複製所有應該被保留的點 才能找到下一個自由點
     就知道後者在時間複雜度上的優勢了
** 漸進性
   * 漸進性 在於
     不需要集中處理所有的運算
     而可以把運算分開來進行
     具體到 數據分配器 就是
     隨時複製[或標記]一寫點都可以
     只要在工作週期的節點保證把所有的工作都昨完就行了
   * 其優點不言而明
     但是如果缺點也很大
     那麼就有理由把這個性狀實現爲一個可選性狀
** 最終的設計決策
   * 我之前使用的是 標記 式 數據分配器
     並且我還發展了一些小技巧來 增加它的漸進性
     但是現在經過考量後
     我決定要轉而使用具有更好的一致性的 複製-壓縮 式 數據分配器
   * 我想出了結合兩種算法的優勢的方式
   * 現在
     我相信我找到了最好的算法
     我的算法將使得 在使用 複製-壓縮式 數據分配器 的時候
     [即[理論上]更優的時間複雜度]
     也能獲得漸進性
     並且正確處理 循環引用[所謂的指針運算][native pointers]
     作爲一個 具有漸進性的 數據分配器
     在最壞的時候 它也能證自己的正確性
   * 蟬語 中某些數據類型被 數據分配器 來處理的
     但是 另外也有靜態的數據
** CPU 緩存
   * 關於 遍歷方式
     注意 當使用 單向鏈接的鏈表的時候
     以 cdr 開始遍歷可能是最好的
     而當使用其他模式的數據的時候
     遍歷方式也應該跟着改變
     其目的在於 把相近的東西放到一起
     因爲 CPU cache 的存在
     如果 相近的定西 在同一個 cache line 中
     那麼引用的時候速度對提高很多
** 對結構化數據的複製 與 hash-table
   * 只要在遍歷中進行複製就行了
     爲了正確處理結構化數據中的循環引用
     所需要的只是擁有一個機制
     能夠幫助記住之前有哪些點被複製過了
     1. 對於複製壓縮型數據分配器來說
        每個點上有一個域 專門用來標記是否被複製過
        又有一個域 專門用來記錄被複製到的新地址
     2. 而對於一般的複製來說
        可以使用各種各樣的算法
        最樸素的算法將導致 O(n*n) 的時間複雜度
        可以利用類似與複製壓縮型數據分配器的原理
        讓 copy 函數擁有一個 地址的 hash-table
        來模擬每個點上的 兩個域
        注意每次 copy 一個東西之後
        hash-table 都要被清空
        爲了避免每次去清空 hash-table
        可以動態生成用以標記佔用情況的數值
        從 1 開始 到 很大的數纔會結束
        每當耗盡動態生成的數值的時候
        再清空 hash-table
        這裏的時間複雜度是 O(n)
        [其實根據具體的 hash-function 複雜度可能還會大一點]
   * 注意上面所描述的算法對於 等詞 也是一樣
     等詞 爲了處理帶有自我引用的數據
     也需要使用類似的 hash-table
   * 難點在於
     如果給每個需要遍歷數據的函數一個 hash-table
     那麼它將只有一個 hash-table 而已
     也就是說每個這類函數
     都不能是遞歸函數
     這就阻止了數據結構的嵌套
     解決的辦法是
     對於遞歸函數 動態地 分配 hash-table
     每次調用都使用一個新的 hash-table
     也許使用 一個 hash-table 的棧
     這樣可能會將遞歸的深度限制到很淺
     但是我想不出更好的辦法了
* 結構化數據
** 內存分配
   * 被分配的內存有兩類
     1. 靜態區域
     2. 被數據分配器所管理的動態區域
** 基本接口
   * 上面兩類東西的基本接口是相似的
     1. 每次分配得的是一段內存
     2. 對這段內存可以有各種類型的初始化操作
        比如清零和對齊等等
     3. 豐富的元數據幫助
        幫助完成其他特性的實現
        但是
        如果想要足夠豐富
        可能用來保存元數據的區域也應該是變長的
        少量的非變長的數據
        只是爲了定位變長的數據的位置
        這樣可能會大大增加接口的複雜性
     4. 被作爲基本數據塊的東西
        太複雜了是不行的
        因爲我正是需要拿這些基本的東西來構造複雜的東西
        其實
        如果我能找到需要被保存的基本的元數據是什麼
        那麼整個東西也許就不是太複雜的
        1) 長度
        2) 單位大小
           這個也許是可以省略的
           因爲已經有珠子的標準大小了
        3) 上面這兩個就是全部了
           字符串的類型的特點可以用這種方式來表達
           即其單位大小是 byte
        4) 還有更複雜的東西邪
           一定還有
           因爲
           數據分配器是需要能夠判斷
           那些數據塊是可能包含子節點的
   * 結構化的數據以基本接口來實現
** 關於數據類型的等詞
   * 每個數據類型只有一種等詞
