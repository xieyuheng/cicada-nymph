#+TITLE:  蟬語散記 / cicada language prose
#+AUTHOR: 謝宇恆 / XIE Yuheng

* todo
** new
   * 關於 結合代數 變形 與 優化
   * 關於多棧的新語法的設計
   * 關於類型系統的新語法的設計
** write a better meet-undefined-word
   1. 如果我想要在 cicada 的代碼中重寫這個函數
      那麼 只要用一個變量
      讓這個函數調用這個變量中所保存的函數就行了
      這樣我就能以相當精確的方式 重新設置處理未定義的位置的函數了
   2. 另外的使得對某個函數的動態改變稱爲可能的方式是
      直接從 symbol 找到找新的 symbol 所對應的 函數值
      當更新 一個 symbol 所對應的函數之後
      就能 重新設置處理未定義的位置的函數了
      但是這種方式並不是很精確
   3. 那麼我需不需要在 cicada 的代碼中重寫這個函數呢 ??
      也許是需要的
      並且在 不同的 語言核下
      所希望使用的 處理函數可能是不同的
   4. 但是這種全局變量的使用可能並不是很好到的編程實踐
** redesign the debuger
   1. as the "debuger" is defined in cicada code
      it is hard to do good error handling in assembly code
      這是因爲我沒法在出錯的時候即使調用 debuger 來報錯
      - 比如 通常的函數類型的錯誤
        我應該 及時的 調用 debuger 來報告錯誤
        而在不利的條件下 我必須 返回一個出錯碼
        來表示函數 所接受的數據類型不對
** re-writing garbage-collectior
   1. ??? 對於新的 define 要更改 GC
      整個 GC 都應該被重寫了嗎 ???
** make good use of indentation
   1. for wodili 應該 在 wodili 的已有的 解析器 的基礎上
      增加一個 好好 利用 indentation 的解析器
      兩種解析器各自有各自的用處
   2. 把 利用"支撐樹" 來進行相對引用的 性質加到 yaml 中
      就能 形成 我想要的 digrap 的語法
** write a cross compiler
   1. 從最簡單 的 babystep 開始
   2. 編譯 bootloader
   3. 注意要保持設計的靈活性
      或者直接從 文檔開始
      用中文寫文檔 以加快速度
   -----------------------------
   1. 需要 cicada-assembler 的理由:
      1) 統一 命名規則
      2) 讓我 能夠探索一些關於編譯的技術
      3) 有些 小的 CPU 並沒有 類似 fasm 的 合適的編譯器的
         當我有 cicada-assembler 的時候
         我就能不受限制於這個事實了
      4) 當我調整代碼的結構
         以讓我方便地 維護兩個彙編版本的時候
         我就發現 其中有很多重複的部分
         想要消除這些重複
         我可以通過 更多的 把文件 分開來實現
         但是如果我想保持
         我的 類文學編程 組織代碼的風格的話
         也許 創造一些新的東西來支持 我的風格就是必須的了
   2. 不需要 cicada-assembler 的理由:
      1) 一個人認爲 一個語言需要這種東西
         可能只是因爲 當這個語言的編譯器能夠自己編譯自己的時候
         看起來很 cool 而已
      2) 爲了 實現 一個 x86-64 的彙編器
         有太多的 關於 CPU 的底層細節需要 被掌握
** erlang's bit syntax
   在於讓人方便地處理 bit fields
   這在於 能 用模式匹配
** about UI
   我可以把那幾個 核心的棧 的圖示 放在 左邊的一個窗口裏
   在這之後 我就能設計 debuger 的更好的使用方式
   但是一個問題是 當我的界面不再是一個簡單的解釋器的時候
   我就不能 直接利用 emacs 了
   也就是必須 要先寫自己的 文本編輯器
   之後才能考慮窗口 之類的問題
** word boundary
   1. ><><>< the note about word boundary is wrong ???
** branch
   1. 是否對 branch 給更好的支持 ?
      用 label 來計算 offset ???
** english-core
   1. use hash-table to lookup dictionary
      then mutually recursive call
   2. 用hash-table來find
      這些不必實現在彙編代碼中
      因爲 list還是必要的
      因爲這樣就能保持對字典的靈活控制
      所以 需要寫一些函數把
      字典重新加載到 hash-table 中
   3. need to redesign the way to do test
      should tangle test to separated file
      for i do not have my org-mode now
   4. wodyli processing
      then digrap in cicada
   5. tab completion in the REPL
      (or in text editor)
   6. let functions in assembly-code
      be able to call functions in cicada-style-assembly-code
   7. >< 實現對多種實現技術的定製
   8. >< 重新思考某些術語和命名方式
   9. cicada should design it's own abstractions of IO
      this can help cicada to be portable
      現在 有的只是 read-char 和 write-char 兩個基礎的東西而已
      這樣太貧乏了
   10. memory allocation
   11. flow-point number
   12. >< maybe substitute word to execute in lambda-body
   13. >< maybe syntax-check
   14. >< modern pattern-match  HOW ???
   15. better interface for debuger
   16. TAIL-CALL-OPTIMIZATION in apply lambda-body
   17. more protection on allocated memory
       maybe use paging
   18. cicada-assembler
   19. cicada-editor
   20. APL-like array-processing
   21. needs better sexp-reader&write
       design a better way
       to use local-label to from list-with-circuit
** baremetal
   1. 作爲一個使用純粹釋性語言
      我應該 重新 思考 對 公共的 函數庫的使用方式
   2. in lmode, how to set up the "attributes-and-type" field in an entry of IDT ?
   3. SMP support
      作爲一個以棧爲基礎的語言
      我應該重新思考 利用 多核 的方式
   4. learn more from baremetal-OS
   5. convert the code about storage & BMFS from old-asm to forth-like-asm
      to examine the bug of "readsectors"
   6. fix "bye"
   7. design game-like UI in text mode
   8. rewrite cicada to make it standard and portable
      (this will always be TODO)
   9. to allow executables to dynamically access external functionality at run time
      and thereby reduce their overall memory footprint
      在我的操作系統中 我可以以我的方式來完成上面的這種特性
      我只需要一個 "need" 函數 來聲明 某段被解釋的代碼 所需要的 sub-dictionary
      我還需要一些 處理 sub-dictionary 的函數
      sub-dictionary 的性質 是 :
      - 它可以有很多個
      - 並且它所佔用的 內存可以被回收的
      - 內存的回收 可以用 類似字符串的 垃圾回收器 來完成
      - 當全面地使用 hash 來實現 dictionary 時
        內存的回收 也可以用 類似鏈表的 垃圾回收器 來完成
** cicada-idea
   1. cicada-idea 本身是一種開源硬件
      它是專門爲 編碼者 和 開源硬件hacker 而設計的 編程終端
      有專門爲 控制和編碼開源硬件 而設計的 硬件接口
   2. 作爲開源硬件 對 cicada-idea 的銷售和重新設計 不需要被 我 授權
      我 作爲 開源硬件的銷售商之一 而盈利
   3. cicada-idea 擁有 開源的 基於結構化文本編輯器的 操作系統界面
      cicada-idea 以 cicada language 爲主要的編程語言
      cicada-idea 有 以 cicada language 爲主要語言 而開發的 編碼環境
* 工作流程
** 悖論
   * 我先把所有的設計都寫成文檔
     然後再着手實現
     否則當實現到了後面
     如果發現了某些設計需要更改
     就必須更改很多前面的代碼
   * 我能這樣做
     只是因爲
     第一個版本已經被實現好了
     我已經知道在實現過程中可能遇到的技術難題是什麼了
   * 但是第二個版本的設計中
     想要加入和改進的性狀太多
     以至於沒從設計回到實現
** 下一步
   * 關於籌劃項目的籌劃
     所需要知道的唯一一件事就是 下一步做什麼
* 批判 蟬語
** 蟬語之優
   * 某些性質被我認爲是優點
     然而 同樣的性質 在不同的人看來可能是缺點
   * 把對 參數棧 和 返回棧 的處理 明顯地暴露給用戶
     這樣就使得 使用者 能夠對系統的整個運行情況有非常具體而直觀的瞭解
     這個性質是我最喜歡的
     就算是對於 scheme 和 smalltalk 這種設計良好而簡潔的語言來說
     這種對整個系統的直觀理解也是不行的
     因爲 這兩種語言的 簡潔性 是以很高的抽象性爲代價的
     而 蟬語 的設計就是要在 保持這種 被簡單而直觀的理解的可能性的同時
     去實驗某些性狀 以達到 不比 scheme 和 smalltalk 弱的抽象能力
   * 這一點很重要
     簡化 和 底層化 語義的同時
     不能削弱抽象能力
     因爲 抽象 是用來控制複雜性的
     少了抽象就少了控制
     也就是放任的複雜性
   * 獲得關於一個理論的堅固知識的方式就是去實現它
     這同時也幫一個人考察了他所觀察的理論的可實現性
** 蟬語之劣
   * 某些性質被我認爲是缺點
     然而 同樣的性質 在不同的人看來可能是優點
   * threaded-code 的侷限性
     主要在於 這種風格的機器碼很可能 難以優化
     但是其實只有在具體的測試和實驗之後
     才能得出真正的結論
* 數學
** 直觀 與 抽象
   * 用抽象的數學來描述那些
     超出我們直觀的想像能力的東西
     是非常重要的
     每個個體的人的直觀想像能力的侷限性
     決定了他對抽象方法的需要
   * 同時
     我們的想像能力本身卻又是可以拓展的
     就像一個潛水者通過長期的練習就能夠更熟悉水的性質一樣
     對某種語言的學習
     或者對某種新的表達方式的學習
     也能幫我們去熟悉一種新的思考方式
   * 但是我們應該如何來看待我們所學到的某種新的思考方式呢 ?
     我們拓展了我們的直觀想像 ?
     還是我們獲取了新的抽象技巧 ?
     看似對立的 直觀想像 和 符號性的抽象技巧
     本爲一物矣
* 設計原則
** 設計決策
   * 每當一個設計決策的
     * 選項一
       會導致更多的新試驗
       並且有可能讓他做更多的設計決策
     * 選項二
       會讓設計者走向更傳統而有章法可循的實現
     這個時候正常的設計者就傾向於選項二
     這就是爲什麼人們想要
     模塊系統 代碼複用 等等語言性狀
     對於對複雜性的控制而言 這些性狀其實都不是本質的
   * 我選擇做非正常的設計者
     就算我發現一個設計決策可能會讓我重寫很多的代碼
     經過客觀而細緻的評價之後
     只要這個決策是好的
     我依然會作出這個決策
   * 正常的設計者所做的決策 可以被歸結爲 "非理性的決策"
     我發現在生活中的某些方面我也在做着許多的 "非理性的決策"
   * 啓示是
     每次做決策的時候 都要清楚地明白 "非理性的決策" 的存在
     那是人性的弱點
   * 如果我想爲我的語言做廣告
     我可以做一個對比 來展示
     我的語言 在各個小的方面
     是如何優越於 其他它的各種語言的相應方面的
** 正確的设计
   * Simplicity
     the design must be simple,
     both in implementation and interface.
     It is more important for the interface to be simple than the implementation.
   * Correctness
     the design must be correct in all observable aspects.
     Incorrectness is simply not allowed.
     這是就已經實現的部分而言的
     指必須沒有bug
     當沒有達到 Completeness 時
     沒有實現的部分 比如某些特里的處理 就不被考慮在內
   * Completeness
     the design must cover as many important situations as is practical.
     All reasonably expected cases must be covered.
     Simplicity is not allowed to overly reduce completeness.
   * Consistency
     the design must not be inconsistent.
     A design is allowed to be slightly less simple and less complete to avoid inconsistency.
     Consistency is as important as correctness.
     這是因爲 一致性 就表明瞭設計本身的優良
     從長遠的角度看來 一致性 是最有價值的
** 讀代碼者的認知負擔
   * 集成開發環境 是爲了 通過語法高亮和 mimi-buffer
     來幫助代碼的閱讀者來 獲知 詞 的語義
     與命名規則一樣 這一切都是爲了
     減輕 代碼的閱讀者的認知上的負擔
** 語義設計
   * 很多阻礙語義被以正確的方式實現之處
     只在因考慮效率問題而放棄了性質更豐富的數據結構而已
     我應該避免這一點
     在尋求 語義的豐富性 和 實現的高效性 之間的平衡之時
     我傾向於 語義的豐富性
* >< 錯誤處理
  1. 有兩種 錯誤處理機制在 cicada 中被使用了
     * 一種是 在出錯的時候當場 調用 debuger
     * 一種是 在出錯的時候返回 出錯碼
  2. 第一種是 lisp 的 REPL 中常用的方法
     第二種是 C 和 UNIX 中被系統使用了的方法
  3. 以第一用方式實現的函數的特點是:
     儘早地 報告錯誤就能把錯誤報告的更詳盡
     並且給 用戶 當場更改錯誤的機會
  4. 以第二用方式實現的函數的特點是:
     可以一致 的方式 允許錯誤的出現
     典型的 場合是 對 number 的 parsing 錯誤
     ----------------------------------
     但是這兩種 處理方式 又可以 相互實現對方的好的性狀:
     1. 第一種的好的性狀之一是 可以把錯誤報告的更詳細
        第二種風格的函數 只要不要 返回出錯碼
        而 返回更豐富的數據結構 來報告錯誤就 也能達到這種效果
     2.
     3.
* >< bra-ket & 邊綴表達式 & 語境
  * 一個 REPL 的性質很像是 bra-ket 中的 一個 bra
    symbol-REPL 作爲 bra
    所對應的 ket 可以是 bye,symbol-REPL
  * 各個 REPL 和 bra 之間
    必須能夠靈活的相互遞歸調用
    我沒能實現很好的機制來完成這一點
  * 並且我現在應該把 REPL 和 bra-ket 的實現方式統一起來
    我以前並沒有意識到它們是完全相同的東西
    它們之前確實有區別
    但是我應該把它們的共同點提取出來
    >< 這種 "對共同點的提取"
    用函數的 factoring 做起來
    和用 class 的繼承做起來 相比
    感覺有什麼不同 ???
  * 之前的版本中 函數的編譯器[因而 repl] 就是一種特殊的語境
    以 ":" 爲 bar 以 ";" 爲 ket
    在其中
    1. 遇到最一般的詞的時候
       會寫[call word-address]到內存中
    2. 遇到數字會寫[number n]到內存中
    3. 等等
    4. 遇到語法關鍵詞時會調用那些語法關鍵詞來處理
       調用結束之後會再返回主要的循環中
    5. 這個 主要的循環就代表了 "全局之後綴性"
       而對個別語法關鍵詞的調用就代表了 "局部之任意性"
    6. 儘管 函數體是被允許嵌套的
       但是這個函數卻不是遞歸函數
       這個處理函數會以相對線性的方式來語法解析這個函數體
* 蟬語中的命名規則
  回顧一下 cicada 中現在所使用的命名規則
  做一個系統的筆記
  這也將方便將來文檔的撰寫
  1. 首先是關於 primitive functions
     它們的命名都是簡單的用"-"來連詞的
     儘管這裏也有類似數據類型的概念
     比如string[address, length]
     沒有複雜的跟類型有關的前綴
  2. 也就是說"-"是用來把單個的word鏈接成短語的
  3. 而在 basic 中
     還用到了","
     它是用來把短語鏈接成短句的
     比如 "define-variable,by-string"
     在這個例子中 "by-string" 表明瞭
     這個函數的參數的數據類型
  4. ":"被用作前綴的鏈接符
     比如 "Message:bye" 和 "Key-word:then"
     首字母大寫表明他們是名詞性的
     這些常量或變量前綴單單指明瞭
     這個名詞的功能
     而沒有指明這個名詞的實現細節
     >< 這種特性是好的嗎?
     這是好的 如果 人們總能簡單地從這些描述特性的詞中推測出這些名詞的實現細節
     這是不好的 如果 這種推測並不平凡和簡單 而帶來了額外的認知上的負擔
  5. 對名詞而言
     第一個簡單的跟類型無關的描述函數功能的前綴是"help:"
     也就是說前綴的使用方式是相當自由的
     >< 我不應該做更細緻的標準式來削弱這種自由性嗎?
  6. 前綴是可以有多個的
     比如"help:string:copy"
* 編程範式
  * imperative
    to describe computation in terms of statements
    that change a program state
    in much the same way that imperative mood in natural languages
    expresses commands to take action
  * object-oriented
    computation should be viewed as an intrinsic capability of objects
    that can be invoked by sending messages
    其重要的特點是這樣的模型非常節省用來定義函數的命名空間
    這樣是以數據結構爲中心的
    函數 (算法或對數據結構的處理過程) 在思想觀念上的重要性 屈居次位
    這是在嘗試
    讓我們的編程行爲適應我們對這個世界的最通俗的非結構化的理解
    我們能夠辨別我們在這個世界上所觀察到的各種物體(對象)
    並且我們總在以某種方式與這些對象交流
    每個對象是一個內蘊的獨立的個體
    並且在我們的觀察過程中
    我們給對象分類
    分類在這裏其實是不重要的
    - 這是因爲分類不是一個系統的方法
      分類的過程可以是相當任意的
      不同的分類者 去分類 同一個對象的集合時
      按照他們的理解方式的不同 他們會作出不同的分類
      看看生物學就知道了
    重要的是每個內蘊的個體
  * functional
    computation should be viewed as functions act on their arguments
    並且這些函數的行爲 要具有數學意義上的函數的某些重要特性
    這是以算法爲中心的
    這是在嘗試
    用我們的數學知識來幫助我們編程
    而數學代表了我們對這個世界的結構化的理解
    我們觀察這個世界
    然後用數學的語言還有數學的方法論總結我們的觀察結果
* 古漢語
** 方法
   * 蒐集古典例句
     查而辨其結構
   * 語言有一奇妙特性
     在於 它能被用來描述它自身
     正是因爲這一特性
     寫一篇辨析語言結構的文章才成爲可能
   * 在辨析結構之時
     需謹記 因 語言成於人與人之間的交流
     故 重任交談之場景 反映於語言之結構中
** 界說
   - 詞類 ::
   - 名詞 :: 名詞爲本
   - 動詞 :: 動詞以述名詞之行也
        不可獨解
        解時 需助之以名詞或代詞
   - 形容詞 :: 以形名詞之容也 不可獨解
        但是上面的界說是有問題的
        因爲 數 應該被視爲形容詞
        但是 數 又被當作抽象的名詞來被處理
        並且形容詞所形容之性狀通常都是可以被量化的
        所以 形容詞對名詞之限定 與數之結構息息相關
        並且所謂用來形容動詞的狀詞亦可以被量化
        但是 其實作爲限定詞 它們也有簡單的限定分類之用
        未必階爲狹義的量化
   - 數學結構 :: 動詞是這些性質就時間而言的變化
        然而要點是
        語言的語義就 對話場景
        還有 時 空 二量 而 優化了
        這種優化可用關於演化的理論來解釋
   - 更細的特點 :: 我其實是在類比數學語言與自然語言
   - 句讀 :: 句讀者 語法解析 也
** 判斷
   * 判斷句
     不用 "是"
     而並兩個名詞短語然後加後綴 "也"
   * 這就使得中文看起來像是沒有語法的語言
     做語法解析需要憑藉對語義的理解
     而"相對"正確的語法解析
     又是得到"更"正確的語義的前提
     所以我們的大腦中處理漢語意義的模塊像是一個迭代函數
     我想
     讓這個"迭代函數"發散的點是存在的
** 簡體繁體
   * 簡體 繁體 西文 和所謂也 ?
     聲韻形態皆思之載體
     過分追究表達方式之異同之人
     未嘗得道也
   * 在蟬語中 以傳統漢語爲主要表達方式
     而在命名規則和別名系統的幫助下
     我可以讓 簡體 繁體 西文 並存
** 句式
   * 以 主 謂 賓 爲基礎語順
     施 句式 以變
     1) 使成
        主 謂 賓 成 : 燒燭短 引杯長
        主 謂 成 賓 : 折斷 吹散
     2) 被動
        賓 爲 主 所 謂
        賓 被 主 謂
     3) 把
        主 把 賓 謂
   * 而蟬語的特點是
     在大多數情況下 動詞後置
     並且似乎沒有主語
     或主語爲隱含的 我
   * 凡 []
     [] 者 曰 []
     [] 者 曰 []
     用以描述大類下的小類
   * 語法其實就是一個樹狀結構
     需要設計的是如何把這個樹狀表示出來
   * (名 體*) 動詞也
     (名 體* 詞性) 而 編撰入詞典
     (名 體* 詞性) 也
     (體* 詞性 名) 也
     蓋 體* 詞性 名 者 也
     #+begin_src cicada
     蓋 (* n -- n! *)
     復 一乎 則 已矣
     再 復 1 減 階乘 乘 已矣
     動詞 階乘 者 也
     #+end_src
     "也" 簡單地由 "而 編撰入詞典" 就語法優化而來
     一個字符串 接受到 "編撰入詞典" 這個信息的時候
     會調用一個處理函數
     這個處理函數
     會把字符串語法解析了
     然後把一個詞的定義編撰入詞典
* 具體語法
** 詞
   #+begin_src cicada
   詞 静
     名 我希望這是被內化的串 即符號
     大小
     性
     詮釋者
     定義

   用來初始化 詞 的函數 會把詞分配到 詞區[詞典]中
   也就是說每個[某些]數據類型會有自己的區
   #+end_src
   1. 初始化
      先看 在舊的 依賴於外部的匯編器 依賴於解釋語義的 實現方式中
      初始化 是如何實現的
      1. 首先在匯編中
         定義之外的部分用一個宏實現
         定義就是簡單地把地詮釋者的地址留在匯編代碼中
         也就是說
         爲了形成一種寫匯編代碼的風格
         詞這個數據的結構被限制了
      2. 在解釋器中
         讀一個串
         把這個串解析成詞
         第一個詞爲 名
         以之後的詞 找對應的詞的詮釋者 以爲定義
      故 初始化之語法 類似於
      夫 <某> 者 <某> 也
      或
      夫 <某> 者 動詞 而 編撰入詞典
      如果 想 保留 也 這個詞 那麼就需要一種語法糖機制
      因爲 否則 就破壞了召喚函數的統一性
      但是這種統一性也許是需要被破壞的
      考慮 cons 就知道了
      名詞 和 動詞 是兩種類型
   2. 處理
      並沒有很多的處理函數
      對這個函數的處理都是散列表和名之間的互動
      可以說 散列表和詞 一同構成了詞典
   3. 統一性
      定義一個數據類型的語法是統一的
      帶有類型標籤的量在參數棧中的存在方式是統一的
      取非原子性的數據的域的方式是統一的 :: <型> 之 <域>
      召喚處理某種類型的函數的方式是統一的 :: <型> 而 <函數>
      統一性僅此而已
   4. 不統一性
      也就是說用來初始化各種數據類型的值的語法是不統一的
      數據類型存在於內存中的方式也是不統一的
   5. 型 類似於 名詞
      夫 詞 <某> 者 名詞 而 編入詞典
      設計何種語法才能把對型的 域 和 處理函數 的描述
      置於型的定義之外 ?
      這是不合理的
      對型的 域 的描述不應該被置於型的定義之外
   6. 所謂的之和而其實是相同的
      之 也是在召喚函數而已
      這樣就獲得了純粹的動態性
      之 <某> 會被編譯成 [某符號] [之]
   7. 某個數據類型的所有的處理函數
      都在類型的定義之外聲明
      其實就是把這些函數登記在這個類型下面
      並且我必須提供語法
      使得用戶能夠方便地把一批函數一起登記
   8. 只要做了下面所述的優化
      那麼以一致的方式來實現對數據域的處理也就可以了
   9. 不去定義標準的初始化一個數據類型的域的方式
      就能夠 保持 使用類型系統時候的靈活性
      好的 factoring 能夠保持 表達方式的精簡
   10. "而 編撰入詞典" 到 "也" 這種對語法的優化
       其實可以以一致的方式系統地使用
   11. 我說 ruby 識別出了一種 使用 lambda 的模式
       並且就這個模式優化了自己的語法
       器關鍵在於把 顯式的參數 變成 隱式的參數
       蟬語的語法必須具有 "可以做類似優化" 這種性質
       蟬語保持平凡的核心語法
       而在蟬語中對語法的優化 是由核心語法所提供的語義來完成的
       也就是我必須設計一種 讓用戶去優化語法的機制
   12. 可以看出在 有類型系統的 函數式範式中
       只要
       調整調用函數的前綴或後綴表達式爲順序爲中綴表達式
       然後在加上把某些 顯式的參數 優化成 隱式的參數
       就形成面向對象了
       而 我想 面向對象 所增加的認知上的負擔是很重的
       所以我放棄對 面向對象 系統的實現
   13. 蟬語所實現的東西 與一般的OO範式所不同的是
       1. 最重要的是沒有提供一致的方式來初始化類型
       2. 法上保持 後綴表達式
   14. 那麼定義一個類型的語法應該是如何的呢?
       我應該提供語法來幫助用戶
       在定義類型之初就指明有那些函數需要登記
       >< 我還希望能夠該處一致的方式在 定義好了一個類型之後
       再在其中登記 一個或多個 函數
       我希望登記 一個或多個 函數 的語法能夠一致
   15. 我甚至還能夠提供 所謂的 Class Variables
       因爲 這種 "把函數登記到類型中" 的解決問題的方式
       是非常靈活的
** 關於優化
   1. 如果 在把 之 或 而 編譯到動詞的定義當中時
      如果能夠證明 這個函數被調用時 棧頂的數據的類型是固定的
      那麼就能夠把查找的過程在編譯期完成
      從而優化運行期的效率
   2. 最顯然的可以證明的情形是
      當它前面被編譯的是一個原子性的數據的時候
   3. 對於取非原子性數據的域的函數
      這種優化可以更進一步
   4. 可以發現這裏所謂的優化
      就是簡單把某些計算在編譯時期進行而已
      那麼
      如果在編譯時期遇到 1 2 + 這樣的函數體
      是否也要計算出這些結果呢
      答案是肯定的
      如果我總是保證在編譯期能做的計算都在編譯期被算完
      那麼顯然我就能證明
      就從這個角度的優化而言 我的編譯器達到了最優
   5. 但是
      lambda 如何呢 ?
      在 lambda 的函數提中如何呢 ?
      純粹地動態嗎 ?
      沒錯
      其函數體也是可以以類似方式優化的
      因爲我可能要歲 lambda 做手術
      所以 對於實現與否
      我把決策放在以後在做
** 符號
** 定義
** 棧
** 整數
** 八位組
** 字
** 八位組串
   #+begin_src cicada
   八位組串
     蟬語者說
   ------------
   #+end_src
** 單鏈
   #+begin_src cicada
   (* bra-ket *)
   { Mark-McGwire Sammy-Sosa Ken-Griffey }

   (* indentation *)
   ======
   - Mark-McGwire
   - Sammy-Sosa
   - Ken-Griffey
   ======
   #+end_src
** 雙鏈
   #+begin_src cicada
   (* bra-ket *)
   [ Mark-McGwire Sammy-Sosa Ken-Griffey ]

   (* indentation *)
   ======
   * Mark-McGwire
   * Sammy-Sosa
   * Ken-Griffey
   ======
   #+end_src
** 名鏈
   #+begin_src cicada
   (* bra-ket *)
   ( :hr 65 :avg 0.278 :rbi 147 )

   (* indentation *)
   ======
   :hr 65
   :avg 0.278
   :rbi 147
   ======


   ( :american
       Boston Detroit New-York
     :national
       New-York Chicago Atlanta )

   ======
   :american
     - Boston
     - Detroit
     - New-York
   :national
     - New-York
     - Chicago
     - Atlanta
   ------
   :1 "-" for list element
   :2 "*" for dali element
   :3 ":" for wodi (* wodili element *)
   ======
   #+end_src
* 計算的方法
** 木答演算 [lambda-calculus]
** 有向圖處理 [digrap]
* 計算的方向
  1. 使用明顯的 參數棧 與 返回棧
     對於使 call/cc 的語義變清晰來說
     很有幫助
  2. "沒有祕密,就沒有泄密"
     "沒有抽象,就沒有抽象的泄漏"
  3. 在形成一個 cc 的時候
     應該可以以明確地方式說出所使用的是哪段計算
     這樣 call/cc 的語義就不會再令人迷惑了
  4. 如果我能以明顯的方式把各段運算
     以隱式抽象成函數
     然後隨意地組合它們
     然後在根據常用情況優化其語法
     那麼我就得到比 call/cc 更好的東西了
  5. 好像 call/cc 無論如何都需要複製參數棧
  6. call/cc 的難點在於
     必須使用動態地方式來分配 函數返回地址 和 函數參數 的內存
     然而它們會大大加重 GC 的負擔
  7. call-with-* 其實是改變了 函數作用的基本語法的
     (call-with-* <function>)
     它讓函數作用於一個約定的參數
     而不是使用
     (<function> <約定的參數>)
     爲什麼如此呢 ???
* 矛盾
  * 高階與低階
    如果使用自己定製的虛擬機
    並且把 GC 實現在虛擬機中
    那麼 蟬語 之簡單性所帶來的對機器底層的控制能力就喪失了
    除非虛擬機的可擴展性非常強
    這樣在需要某些新的底層功能時
    就可以通過擴展虛擬機而完成
    也就是說
    虛擬機知道自己是一個虛擬機
    並且它提供通向更底層真實硬件的接口
  * 特性之意義的喪失
    所保留下來的特性還有什麼 ?
    [如果 獨特之處 全然喪失 那麼我就應該回到 scheme 社區了]
    1) 以明顯方式使用的棧
       [函數語義的具體化]
       後綴表達式
       [達到與CPS同樣的效果][避免複雜的語法解析]
       無傳統意義上的局部變量
       [就函數複合而優化[同時使得對函數作用的表達變得羅嗦]]
       [也就沒有因局部變量的大量使用所帶來的認識上的負擔[但是引入了其他類型的額外的負擔]]
       這些特性 使得
       1. 蟬語是一個非常適合教學的語言
          比如
          犧牲效率而換取設計的一致性
          不做優化而換取實現的簡單性
       2. 在學會使用蟬語的同時 基本上就學會實現蟬語了
    2) 漢語本位
    3) digrap
    上面就是我能想到的全部了
    如果再強行描述其他的特點或優點 那就是不實的廣告了
* 對鏈表的排斥
  1. 人們先驗地認爲鏈表處理速度慢
     但是這是用速度來買靈活性的時候
     [看看minikanren就是全然用鏈表處理實現的]
     [而digrap將來也將全然使用鏈表處理來實現]
     [我想coq也是如此]
     [既然它們都是如此 那麼鏈表也就沒有什麼不可接受的了]
     所以我不再排斥鏈表處理了
* 空間換時間
  * 通過把 function-address
    豐富爲 call function-address
    就做到了 在需要做判斷[形成很多分支]的時候
    避免判斷
    從而用空間來買時間
    這種想法可能在很多地方都適用
    [比如下面]
  * >< 把函數體保存在鏈表中
    與把函數體保存在數組中
    這兩種存儲方式是否能夠相容??
    也許使用上面的技術就可以了
  * 還有很多地方都可以這樣做
    比如 其他需要判斷是否到達數組的末端的地方
    都可以使用類似上面的技巧
    這優點類似於面向對象中
    把處理函數封裝到數據結構中一樣
    封裝之後
    我就可以把
    [判斷+調用]-優化爲->[調用]
  * 以這種技巧
    我就能在棧中插入鏈表
    假裝鏈表是棧的一部分
    從而實現 明顯定界的 continuation
  * 只要用標籤來標記有可能需要被捕捉的地方
    然後 當標籤都被處理完了之後
    在從使用 鏈表 轉回到 使用 棧 就行了
* 雙向鏈接的鏈表
  * 也許我應該直接以雙向鏈表爲基本數據結構
    因爲 它能夠被當作 單向鏈表來使用
    這樣就增強了設計的一致性
    我可以把鏈表單元的實現
    從 [car cdr] -優化爲-> [data <- ->]
  * 這也能成蟬語的另一個特點[賣點]
    即 極端[不顧成本的]富的數據結構
* 函數複合 與 變換
  * 應該以 函數複合 爲基礎來組織語言的基礎語義的數學基礎
    想要找一個數學基礎的原因是[且只是]
    爲了能夠得到一套規則來對代碼的表達式進行推導
  * 複合的時候對參數有一個檢查是合理的
    但是又是困難的
    因爲參數的入棧和出棧是可以很靈活的
    把參數用一個名字打包 就能形成一個對參數的額外聲明
    也許這種技巧能夠解決 推導與變換 的問題
* 優化與變形
  * 具有局部變量和以函數作用爲主而實現的 lambda 演算中
    可以看到
    利用對 lambda-term 的變形
    可以對程序做出很有趣的觀察
    這些觀察和變換可以用來優化程序
    這都是因爲 lambda 演算 的良好的數學性質所導致
  * 而
    在蟬語這種以函數複合爲主的語言中
    如果仔細甄選原子性函數[如joy所做的那樣]
    那麼就也能達到有趣而良好的數學性質
    這裏所謂的良好其實是說
    利用這些性質我們能對一段函數做很多的恆等變形
    就像是對一個數學公式所做的那樣
    這樣就也達到了 lambda 演算 的優點
    [這些是組合邏輯的課題]
  * 關於高階
    只有當這些變換能夠對某些高階的函數而進行的時候
    才會有用
  * 把運算在編譯時期來做就是了
    但是理論上能夠在編譯時期做的運算可能是非常多的
    >< 這裏需要一個分析
  * 當我純粹在使用函數複合的時候
    所謂的變換
    就是以個複雜的 代數 而已
    只要研究這個代數的性質
    我就能獲知 那些變換是可能的
    [我想在這裏 我能得到很多數學上的支持]
    [也許我還能反過來給數學一些新的啓發]
* 結合代數
  * 蟬語 是最有趣的結合代數
    利用這個結合代數似乎可以模擬任何代數結構
    [甚至是非結合代數]
    1) 比如上面對函數作用的模擬
       [儘管函數的作用不是結合的]
    2) 又比如我可以把兩個矩陣入棧
       然後一個矩陣乘法函數可以像 "*" 乘兩個數一樣
       爲我返回矩陣的積
       [儘管矩陣乘法不是結合的]
    3) 又比如列表處理可以用來實現 digrap
       而 digrap 已經出離代數的範疇之外了
       但是它還是能夠被forth的結合代數所模擬
  * 但是僅僅 "是" 一個結合代數
    這個性質太弱了
    我所需要的是能夠形成 "運算律"
    以對 "代數表達式" 進行 "形變"
    這可能就非常難了
  * 要知道
    當你所處的範疇越大
    你所能獲得的特殊性質就越少
    而 "運算律" 正是依賴於這些特殊性質的存在的
  * ><><>< 也並不是不可能
    但是可能需要全新的技巧了
* 關於表達式的形態
  * 對於被當作二元運算的二元函數來說
    只有當這種二元運算滿足結合律的時候使用infix纔是令人滿意的
    + 比如: + * max min gcd `函數的複合' `字符串的並聯' 等等
    這正是joy所想要表達的
  * 對二元運算的結合性的證明 可以被轉化爲對一種特殊的交換性的證明
    #+begin_src
    (p+q)+r == p+(q+r)  <==>  pq+r+ == pqr++  <==>  +r+ == r++
    或者:
    (p + q) + r  ==  p + (q + r)  <==>
    p q + r +    ==  p q r + +    <==>
    + r +        ==  r + +
    #+end_src
  * 再考慮一下別的運算律 簡直有趣極了
    #+begin_src
    分配律(或者說對某種同態變換的描述):
    中綴表達式: (a+b)*c == (a*c)+(b*c)  <==>
    後綴表達式: ab+c* == ac*bc*+  <==>  ???
    但是至少我知道 +(c*) =/= (c*)+
    要想填上上面的問號 可能就需要 λ-abstraction 的抽象性
    否則我根本沒法描述某些東西

    交換律:
    a+b == b+a  <==>  ab+ == ba+  <==>  ab == ba

    +* =/= *+
    abc+*  <==>  a*(b+c) =/= a+(b*c) <==> abc*+
    #+end_src
  * 把後綴表達式考慮爲對棧的操作是自然的
    並且這樣的理解方式所帶來的一個很大的好處就是實在性
    這就又回到了哪個"小孩玩積木"的比喻了
    比如我的十三歲的弟弟可以問我"那個函數的參數是從哪來的?"
    我就告訴他是從棧裏拿出來了
    "那個函數的結果去哪了?"
    我就告訴他結果放回到棧裏了
    數學 和 編程 就都像一個小孩在玩積木一樣
    對了 他還可以問我這個函數是從哪裏來的
    我就說是從詞典裏找來的
* 優化
** 對變量的靜態類型聲明在於
   * 每次在使用這個變量的時候
     都可以決定應該調用的函數的類型了
     但是種情況在蟬語中好像不存在
     因爲根本就沒有局部變量
   * 實是存在的
     因爲有僞局部變量
   * 如果對於爲局部變量
     很多函數也能在編譯期被作用那就好了
** 還有一種極端的優化是
   爲了在編譯期獲知某些信息
   而在編譯器就執行某些應該在執行期進行的函數[到一定的限度]
** 我在這方面的知識還很欠缺
   不能說更多了
   但是沒有局部變量這個特性
   可能會對優化的程度有影響
* 靈活性
  * 在設計語法和語義的時候一定要保持靈活性
    因爲
    所遇到的實際問題可能是多種多樣
    其形式無可預料
    靈活性纔是獲得更強表達能力的關鍵
    而
    爲了以更簡潔的方式來表達某些語義
    而設計出來的具有針對性的語法
    其重要性
    是不能與靈活性本身像比的
* 組合子
  * 在 scheme 中組合子也是經常被用到的
    也就是說
  * 組合子 之集合的有限性
    還有其實現的簡單性
    [相比 lambda 演算而言]
    可以用來形成 對嵌入式系統的函數式編程
* 代數性質的退化
  * 如果考慮整個結合代數整體
    它作爲代數的性質是嚴重退化了的
    與置換羣中的置換相比這裏用來做複合的函數簡直是怪物
  * 重點在於不要考慮整體
* applicative & compositive
  1. 以 空格 爲函數作用
     那麼所形成的符號體系 就很代數非常不同
     比如 SKI
  2. 複合語義 與 作用語義
     是想通的
     組合子並不對 複合語義 有特殊的價值
     組合子 的意義在於
     有限性
     有限個組合子以奇異的方式[指可讀性差的]複合
     而不同於傳統的 lambda
     用一個靈活的方式構建出無限的函數[包括組合子]
* 作爲新的計算模型 digrap 能否用來解決 "不能解決的問題"
  1. 比如組合子正規性的不可判斷性
     但是事實是 任意給出一個具體的組合子
     我都能[用某些奇技淫巧]判斷它是否是正規的
     所以這 "組合子正規性的不可判斷性" 個名命題
     高次方程 "不可解" 這個命題
  2. 那麼我能否給出類似 golais 的方法呢 ?
* 試試
  #+begin_src cicada-nymph
  (* for named functions and there applications *)
    function2
  <:arg2-of-function1
    100
  <:arg1-of-function1
  (function1)

  (* 下面的語法可以形成一次 curry
   * 即它將入棧一個匿名函數
   *)

  | 100
  <:arg1-of-function1
  (function1)



  (* for non-named functions and there applications *)

  (* 匿名函數 作爲一個數據結構
   * [我想說的是一個數據類型]
   * [我想用雙向鏈接的鏈表來實現這個數據類型]
   * 因該具有一套完整而特殊的處理函數的
   * apply 就是其中最重要的一個
   *)

    function2
  <:arg2
    100
  <:arg1
  [ :arg1
    :arg2
     ...
    <function-body> ] apply

  (* 匿名函數一般都會有約束變元 *)



  (* 匿名函數 作爲一個數據結構
   * 其初始化 必須與定義數的方式相一致
   * 也就是說它必須有相當的完備性
   * 有完整的註釋性的信息
   * [關於 關於默認的作用方式]
   * [關於 棧中重命名]
   * [關於 副作用]
   * [關於 到數據類型的註冊]
   * [等等 等等]
   * [也就是說 我在這裏需要提供設計良好的 註釋格式]
   * 所以下面這種簡單的函數作用是 不存在的
   *)

  [ function2 ] apply

  (* 而應該是
   * 即使在定義零元函數的時候
   * 也應該有註釋性的信息以說明
   *)



  function2 call (* 動態的 比如剛出某棧的 符號 可以被動態地調用 *)
  ==
  (function2)    (* 相對靜態的 *)
  #+end_src
* >< 對鏈表複製的優化
* 對新的語法的理解
  * 這裏其實是有和 digrap 的共同點的
    在 digrap 中 考慮 gexp <...> gexp
    其中 <...> 作爲一個中綴的運算
    [只不過這個運算不是單一的一個函數 而是被參數化了的]
    [有結合律的話 就應該使用 中綴表達式 這被看成是語法上的一種優化]
    而在 cicada 中 <:arg 之類的東西
    對參數的表達就像是上面的中綴一樣
  * 啓發有二
    1) cicada 中的函數複合和圖的複合類似
    2) digrap 中爲了用線性的代碼描述兩個圖之間的複雜鏈接方式
       可以使用類似 "棧處理" 的技巧
* 關於對語法的優化
  * 即使全局的語義是相同的
    不同的語言的語法
    也可以是
    就不同方面的語義而優化的
  * 這樣
    每種語言的設計者
    就是在用自己的設計決策
    來鼓勵用戶對某子語義的使用
  * 也許對子語義的鼓勵不是有意爲之
    而只是簡單地想要看看換一種表達方式之後
    理解起來會有什麼新的角度
* 關於大小寫
  * 不能利用 [拉丁字母的] 大小寫 區別來區分語義
    這一點 已經變成了 語法設計中的 一個重要原則
    因爲 漢語 沒有大小寫之分
  * 比如 我不能用 SWAP 來代替 (swap)
    但是
    又確實能夠區分出
    這類 操作棧的函數 和 其他函數之間的區別
    那麼如何在語法中體現這寫區別呢 ?
    只能利用 詞的 特殊的 前綴後綴
    或者 前置後置 的語法關鍵詞了
    其實這就說明了 根本不應該從語法上去區別他們
    文本編輯器
    在做語法高亮的時候
    應該能夠根據語義來分別高亮他們
    但是這也許非常難
    [可能性是肯定的 因爲所有的信息都在文本當中了]
    效率上可能是不能接受的
    [如何設計文本編輯器的構架 以達到可以接受的效率呢?]
* 關於多棧於局部變量
  1. 首先 如果函數體用鏈表來實現的話
     那麼我已經有處理局部變量的存在範圍的算法了
  2. 而當 堅持使用數組來實現函數體的時候
     這種變量的存在範圍有沒有可能被正確地實現呢 ?
     此時又有兩種選擇
     1) 用 棧 來實現局部變量
     2) 用 鏈表 來實現局部變量
     如果考慮對 call/cc 的支持的話
     好像根本就沒有什麼可猶豫的
     必須用鏈表來實現一切
     哦
     這一點我之前討論過了
     兩種實現方式可以交互使用
     以減輕 數據分配器 的壓力
     [要知道被分配在堆中的數據 是一定是要被數據分配器複製的]
     [否則就相當於把兩種類型的數據分配器交叉使用了 會引出很多問題]
  3. 也就是說匿名的函數體在堆中[爲鏈表]
     而有名的函數體在詞典中[爲數組]
  4. 當沒有 cc 出現的時候
     用數組來實現參數棧
     當有 cc 出現的時候
     用鏈表來實現參數棧
  5. 還有一個問題就是
     有名函數之函數體
     之內有匿名函數的時候
     應該如何處理約束變元的綁定範圍
  6. 比如
     這個有名函數返回的值是一個經過代入約束變元而構造的匿名函數
     [每次必須返回一個新的函數體 [需要複製][而不能簡單返回引用]]
     是否應該支持兩種 返回方式呢 ?
     一種是複製 一種是引用 ??
  7. 又比如
     這個有名函數中只是簡單的使用匿名函數的函數體來形成語法解析樹
     [此時 其內的匿名函數體 所需要佔用的內存 靜態地分配到數組中就可以了]
  8. ><><>< ??? 上面這兩種區別應該怎麼處理呢 ?
     [這還沒說到如何處理約束變元呢~!]
  9. 還是有一個 env 的概念
     也就是約束的局部變元的綁定
     [其實在用鏈表所形成的簡單有向圖的時候 並不需要 env 的概念]
     其實這種有向圖處理可以運用在上面那兩種情形上
     如果這樣實現的話
     那麼每次數有新的作用的時候
     約束變元的綁定就會被更新
     如果在情形1中 不返回複製的話
     那麼局部變量的值就要亂變了
     所以必須複製 以返回
     [被綁定的東西是在 葉節點 這些 葉節點 被複製之後語義就對了]
  10. 在理解上
      這種 複製與否 的問題在 scheme 中給用戶帶來很大的困難
      [尤其是當實現方式不同時 不同的解釋器的行爲不同]
      那麼我如何設計以解決這個認知障礙呢 ?
      我保持返回引用的可能
      並且強調 如果需要的時候 必須明顯地使用 複製
      在理解上
      考慮 三角和圓圈 的圖就性了
      每個圖上的所展現的實體都有其在內存中的實際存在
      而複製的過程就是
      照着當時[指做了某些約束邊緣的綁定之後的那個時間]
      那個圖的樣子再畫一個圖出來
  11. 如果我的設計無力消除難點
      我就明顯的把這個難點向用戶指出來
* 關於垃圾回收
  * 當大的數組被分配到堆上
    而需要複製他們的時候
    簡單的算法的劣勢就顯現出來了
    [其實這種劣勢一只存在 只不過當有大的數組時很明顯而已]
    所能想到的解決式是
    使用明顯的語法把某些 數組 和 鏈表 放在靜態的內存中
    比如
    有名函數 和 無名函數 其實已經展現出這種分類處理了
    其他的時候也一樣
    這種東西 一定要被實現爲變量的類型
    也就是說還是需要區分常量和變量
    但是要知道
    當編撰好一個詞[靜態的數組]之後
    還是可以重命名這個數組的
    此時字典中 對這個詞的 舊的定義
    已經沒法被[以正常的方式]引用到了
    那麼這些舊的定以所棧的內存就無以被回收
    [因爲其實這些舊的定義還是能夠被非正常的手段被引用到的]
    那麼
    也就是說
    常量 就像這些 有明函數一樣
    1) 他們的值還是能夠被改寫的
       就像詞典中的詞一樣
       [所以不如說他們是 "靜量"]
       但是不能給出接口以改寫這些名所對應的值
       因爲否則的話 就可能把一個 被分配在堆裏的值賦值給它了
       或者像對待詞典中的詞一樣
       只要設計一個 專門對它的賦值語法
       那麼就能夠讓它們的行爲完全與詞典中的詞一致了
       這樣
       名詞就有 恆詞 和 變詞 之分
       [因爲 "動詞" 的緣故 而不能使用 靜 和 動 這兩個術語]
    2) 被定義給常量的
       數組 和 鏈表 不被分配在堆上
       而被分配到靜態的[類似詞典的][永存的]數據段中
    3) 數據分配器 不會把這些變量當作是遍歷時的根節點
       這樣就減輕了 數據分配器 的壓力
       其實我想說 這樣纔是正確的實現方式
       因爲當你知道一個量會長存的時候
       就不應讓數據回收器對它做無用功
  * 注意 恆詞 所綁定的靜態的數組和鏈表
    其中都不能引用到堆中的地址
    這是顯然的
    這樣基本上就要求了 這些數組和鏈表是絕對靜態的
    [然而 堆上的數據當然能夠 反過來 引用他們]
    [這就要求 數據分配器 要能夠辨別各種地方的 數組和鏈表]
  * 可怕一點是
    上面的設計給了變量 三種類型了
    再進一步 我的變量就要帶有類型了
    這樣合理嗎 ???
    數據和變量都有類型 ???
    單純爲了 數據分配器 的效率
    這樣的設計也是必須的 !!!
* array & list
  * to use array wherever possible
    to use list only where necessary
  * 就名詞的分類而言
    上面的設計原則已經彰顯出來了
  * 而別需要考慮這個設計原則的地方是
    1) 有名 與 無名 函數 的函數體
       [無名 的時候 使用鏈表]
    2) 返回棧 和 參數棧
       [當需要 cc 的時候使用鏈表]
* 幾何的遊戲
  * 錯
    更
    不用有向圖
    而恰當地選取更高維的幾何流形爲基本數據結構[基本數據類型]
  * 在拓撲復型中找
  * 數據結構的可表示性有什麼侷限嗎 ?
    比如說
    list 的拓撲有什麼侷限嗎?
    要知道當用它來表示有向圖的時候
    根本就不用做編碼
    而它直接就能獲得某些跟有向圖有關的語義
    那麼當用它來表示高維的幾何體的時候
    是否就一定需要編碼了呢 ?
    不編碼的優良狀態能被推進到何種地步 ?
  * 在引入我的理解方式之後
    lambda 作爲一個媒介
    鏈接了邏輯和幾何
    那麼
    邏輯中的經典命題的幾何意義是什麼 ?
* 高維不行
  * [至少在初期]我根本就不能使用高維幾何體來作爲設計計算模型的對象
    因爲 高維的幾何體不像[由點和線組正的]有向圖一樣
    很容易在紙上畫出來
    這樣
    對高維的幾何體的線性編碼[代碼]
    就會與高維幾何體本身在認知上的形狀相脫節
    也就很難它們來設計 計算模型
  * 並不是說不可能
    只是說這是一個很大的困難而已
    最初的幾個版本的蟬語
    必須避免在這個問題上糾纏
    [需要考慮的問題已經很多了]
* wordy-list
  * 其全部重點就是給語法做一個簡單的優化
    ( ( :key-1 value-1 ) ( :key-1 value-1 ) )
    ==>
    ( :key-1 value-1 :key-1 value-1 )
    因爲既然約束了 :key-1 作爲 symbol 的形態
    就可以利用這種約束來簡化語法了
    僅此而已
  * 其實還有一點
    那就是再利用 縮進 來優化語法
    以以更直觀的方式表達嵌套的 wordy-list
    這些想法來自 yaml
* wordy-list scheme 的例子 [以對比]
  #+begin_src scheme
  (define example-graph
    '(:type <<graph>>
      :0-dimension-geometry-object-list
      #2=[:v vertex-2 :address #2#
          :can (:value 222)
          :abut-edge-list
             (:e edge:2-->3 :address #4#)
             (:e edge:3-->2 :address #6#)]
      #3=[:v vertex-3 :address #3#
          :can (:value 333)
          :abut-edge-list
             (:e edge:2-->3 :address #4#)
             (:e edge:3-->2 :address #6#)]
      :1-dimension-geometry-object-list
      #4=[:e edge:2-->3 :address #4#
          :can (:edge-type black-arrow)
          :abut-vertex-list
             (:v vertex-2 :address #2#)
             (:v vertex-3 :address #3#)]
      #6=[:e edge:3-->2 :address #6#
          :can (:edge-type black-arrow)
          :abut-vertex-list
             (:v vertex-3 :address #3#)
             (:v vertex-2 :address #2#)]))
  #+end_src
* 縮進規則
** 單鏈
   #+begin_src cicada
   bra-ket
   { Mark-McGwire Sammy-Sosa Ken-Griffey }

   indentation
   ======
   - Mark-McGwire
   - Sammy-Sosa
   - Ken-Griffey
   ======

   ====== 的使用是爲了把縮進對齊
   #+end_src
** 雙鏈
   #+begin_src cicada
   bra-ket
   [ Mark-McGwire Sammy-Sosa Ken-Griffey ]

   indentation
   ======
   * Mark-McGwire
   * Sammy-Sosa
   * Ken-Griffey
   ======
   #+end_src
** 名鏈
   #+begin_src cicada
   bra-ket
   ( :hr 65 :avg 0.278 :rbi 147 )

   indentation
   ======
   :hr 65
   :avg 0.278
   :rbi 147
   ======


   ( :american
       Boston Detroit New-York
     :national
       New-York Chicago Atlanta )

   ======
   :american
     - Boston
     - Detroit
     - New-York
   :national
     - New-York
     - Chicago
     - Atlanta
   ------
   :1 "-" for list element
   :2 "*" for dali element
   :3 ":" for wodi (* wodili element *)
   ======

   所以 單鏈 的 單鏈
   -
     - Boston
     - Detroit
     - New-York
   -
     - New-York
     - Chicago
     - Atlanta
   最好不要使用 縮進
   而直接使用 括號
   #+end_src
* wordy-list 的例子 縮進
  1. 下面可以顯然得看出縮進的好處
  2. 但是我必須這幾機制
     以允許其二者的混合使用
     以保持靈活性
  3. 下面的例子中 :abut-edge-list 被用來表達
     點邊相連之關係
     這個 :field 是爲每個幾何體所擁有的
  4. 爲了正確地解析
     必須規定每個 :kkk 後都一定要換行
  5. 我先試着寫出我能夠理解的語法
     然後看看能不能讓機器也理解它
     如果機器不能理解它 爲什麼 ?
  6. 注意到並排寫成的東西
     是第一次語法優化的結果
     如果使用縮進的話好像根本就沒法利用這種優化了
  7. 一個 :key 中
     保存 兩個 wlist 的時候
     有問題
     比如下面 :0-dimension-geometry-object-list 下
     並不是一個單一的 wlist
     而是一個 list 的 wlist
     這就是問題所在
     這種 list 和 wlist 的混合導致了難點
     但是 無名者是需要的
     因爲否則就太羅嗦了
     通過添加 "*" 可以解決這個問題
     並且需要放棄 單鏈 而全部使用 雙鏈
     否則就太複雜了
  8. 可以發現圖的幾何語義限制了上面的列表的樣子
     1-dim幾何體 能且只能 與兩個0-dim幾何體相連
     並且其鄰接列表是有序的
     0-dim幾何體 能 與0個或1個或多個1-dim幾何體相連
     並且遺忘了其鄰接列表的順序
  9. 這種限制並沒有在我的表示中被表達出來
     這代表兩點
     1) 我的表示並沒有利用這些特殊性狀
        而如果利用這些特殊性狀的話就可以簡化編碼方式
     2) 我的表達方式有被以一種更廣義的方式理解的可能
  10. 推廣在於
      可以有n-dim幾何體列表
      幾何體都可以和任意維數的幾何體相連接
  11. 但是
      可笑指出在於
      高維幾何體之間的鏈接方式並不是這裏的鏈接方式這麼簡單的
      這裏我就找到了侷限性的本質
      這在於
      這裏表達幾何體之間關係的編碼方式是
      在一個幾何體中保存另一個幾何體的地址
      - 並且
        此處還需要同步 兩個相鄰的幾何體內 所保存的數據
        因爲相鄰關係是相互的
      除非我讓編碼方式更豐富
      否則就沒法使用高維幾何體
      想要形成代數拓撲中的某些復形的語義
      並沒有那麼容易
  12. 但是其實也相當接近了
      因爲拓撲變換是非常極端的
  13. 考慮對二位拓撲流形的分類
      就知道編碼的難度了[這還沒有考慮有邊流行]
      哦
      編碼其實不難
      畢竟分類問題已經解決了
      但是我需要的不是能夠解決分類問題的編碼
      而是需要
      使得對幾何體的豐富的處理方式之表達成爲可能
      的編碼
  14. 並且有向圖根本就不是流形
  15. 可以發現下面的新語法
      是沒有歧義的
      機器也能理解了
      只要記住
      :argx 1 :argy 2
      和
      :argx 1
      :argy 2
      是同樣的就行了
      即
      並排者 和 並列者
      爲同一層次的 key
  16. 例如
      :abut-vertex-list
      中
      兩個點在這個列表中儲存的順序
      可以用來體現
      這條邊連接它們的方式
  #+begin_src cicada-nymph
  example-graph
  ===========
  type: <graph>
  zero-dimension-geometry-object-list:
    * #2=
      v: vertex-2 address: #2#
      can: [ value: 222 ]
      abut-edge-list:
         * e: edge:2-->3 address: #4#
         * e: edge:3-->2 address: #6#
    * #3=
      v: vertex-3 address: #3#
      can: [ value: 333 ]
      abut-edge-list:
         * e: edge:2-->3 address: #4#
         * e: edge:3-->2 address: #6#
  one-dimension-geometry-object-list:
    * #4=
      e: edge:2-->3 address: #4#
      can: [ edge-type: black-arrow ]
      abut-vertex-list:
         * v: vertex-2 address: #2#
         * v: vertex-3 address: #3#
    * #6=
      e: edge:3-->2 address: #6#
      can: [ edge-type: black-arrow ]
      abut-vertex-list:
         * v: vertex-3 address: #3#
         * v: vertex-2 address: #2#
  ===========
  (* 所謂把 digrap[關於新的計算模型的語義]
   * 在設計之處直接融合到 cicada 中
   * 現在對我來說還太難了
   * 現在
   * 我只把 有向圖處理 的基本部分融合到 cicada 中
   * 其實就是一個標記語言
   *)
  #+end_src
* 有向圖處理語言的需要
** daedalus
   * 通過描述
     一個只有根節點被標記了的 有向樹
     和 這些樹上的 額外的 用來形成圈的 有向邊
     就可以實現 lambda-term 這個數據結構
   * 被標記了的節點是這個圖的入口
     我可以沿着有向邊
     或逆着有向邊行走
     以遍歷這個圖
     以這種遍歷方式爲基礎我可以實現 call-by-need
** inference-rules
   * 首先是對 inference-rules 的正確理解
     這裏在有向邊上的行走被視爲是推導過程
     當然這個無窮的有向圖並不是存儲在內存中的
   * 需要不斷的向一個有向圖中引入節點
     新引入的節點有可能以原圖中的節點爲父節點
     或者新引入的節點是一個孤立的點
     等等
   * 必須有一個良好的對有向邊的標記系統
     因爲每個 inference-rule 的一次出現
     都必須被獨立標記
** cayley-graph
   * why not use cayley-graph to model a group ?
     人們以前爲什麼沒有這樣做過 ?
   * 惰性
     因爲有趣的 cayley-graph 常常是無窮的
     所以我必須實現一種對圖的惰性構造
** category theory
   * 範疇論中的論證與實現都是在用一些圖而已
     而代數化地理解範疇論更是能聯繫起來更多的問題
     - 我忘了 "代數化地理解範疇論" 是什麼意思了
   * 範疇論跟 haskell 這種語言息息相關
     但是 haskell 把自己限制在了線性的表示方式中
** beyond
   * 我的有向圖處理語言的適用性必須足夠地廣泛
     在我的語言內
     要同時保證
     對上面所有這些問題的解法
     都可以用簡明的語法描述出來
     並且被有效實現
   * 也許需要同時實現對有向圖的各種表示
   * 也許實現各種不同的表示之間的快速地同構變換
     還要維護對一個圖的多種表示同時存在的情形
     如果同構變換的速度不夠快的話
     這時可能就要接受兩種表示之間的差異
     讓一個圖的多種表示漸進地改變
     即 需要數據的同步
** ending note
   * 使用有向圖處理語言
     而不是字符串或列表處理語言
     可能速度會變慢
     但是這使編程者對代碼的理解更加清晰
     在這方面的 複雜性的降低 所帶來的好處
     完全可以彌補速度變慢所帶來的不足
   * 當使用 =α= 這種概念來處理約束變元的時候
     實現起來出現了困難
     其實就已經說明這種想法錯了
     而應該改用更清晰的方法來實現所希望的特性
     即使用有向圖
   * 當被引入的關係是等價關係時
     比如 =β=
     與其把這種引入理解爲
     對更高一層次的字符串的集合的歸納定義
     還不如直接把等價關係理解爲分類
     - 要知道等價關係本來就是分類
       這是不過是在強調要回到原處的簡單理解方式而已
     然後用與分類有關的算法來實現這些東西也許會好些
     這裏能用圖論來理解嗎 ?
     等價關係就是 一個後繼型關系所成的有向圖中 的無向路
     - 那麼對等價關係所代表的二元謂詞的具體實現
       就變成了一個在兩點之間尋找邊的過程
       如果真的以這種方式去做實現
       那麼效率肯定是低下的
   * 當被引入的關係是由類後繼關係生成的偏序關係時
     比如 -β-> 爲 -sβ-> 所生成
     - "-sβ->" 中的 "s" 指 step
     與其把這種引入理解爲
     對更高一層次的字符串的集合的歸納定義
     還不如直接把後繼關係理解爲有向圖
     這樣纔是自然的
   * 實現一個形式理論的方式如果和最自然的理解方式相一致
     那當然是最好的
   * 去以歸納定義的方式
     定義一個字符串的集合
     其實 意在定義一個樹
     每個被認爲是有效的表達式者
     其實都是樹
     只不過只有葉節點被標記了
     var ::= v | var'
     term ::= var | (term term) | (λ var . term)
     就是典型的例子
     歸納定義的字符串的集合的時候所使用的括號 "()"
     其實是爲了形成樹的語義
     即 如果直接用樹來定義 term 就沒必要使用括號了
     但是實踐中
     機器只能處理線性的代碼
     因此想要在這裏省略括號
     就必須改變機器
     讓它能理解二維的表達式
* >< digrap 的語法設計之不可能
** 箭頭 與 利用相對位置來找到某個東西
   * 像 <:arg 這種東西
     直接把棧頂的東西包裹起來
     而成爲一個可以被對應的約束變元處理的數據類型
     那麼
     可不可以豐富這個箭頭
     使得
     在嵌套所形成的樹裝結構中
     引用別的[嵌套]層次的東西成爲可能 ???
** digrap 的 來自 lisp 的語法
   * lisp 的經歷讓我知道
     在線性的文本中很容易形成樹的結構
     可以以這個樹爲支撐樹
     然後在這個支撐樹的基礎上構造起整個圖
   * 其好處是
     支撐樹中包含了所有的點
     剩下的就只是邊需要被說明了
   * 另外
     還想要用 樹 來編碼操作有向圖的指令
   * 最初的設想中
     只有點元素是被明確給出的
     就像 sexp 一樣
     然後
     每一個點元素中可以保存一些信息
     這些信息可以描述
     1) 支撐樹之外的從這個點出發的有向邊
     2) 這些有向邊是如何與圖的其他部分相鏈接的
     3) 對圖的其他部分的位置的明指
        就利用在支撐樹中的相對位置來表示
     這種設計的可行性可以通過初步的思想實驗的檢驗
     但是這種設計並不令聞滿意
   * 這與 lisp 中形成帶有 圈 的 sexp 的語法之間的區別
     就僅僅是 在那裏使用了全局的標記
     而在這裏 我使用了局部的相對路徑
     而已
     我能描述的東西確實豐富了很多
     但是還是不能說這是很好的設計
** digrap 的 來自 cicada 的語法
   * cicada 的經歷讓我知道了
     可以在線性的代碼中嵌入一些做副作用的小精靈
     讓小精靈來幫忙形成複雜的圖的語義
   * 給出點
     然後讓小精靈去把這些點以各種方式鏈接起來
   * 觀念上的一個轉變是
     雖然代碼還是作爲線性的文本被提交給機器
     但是對線性的東西可以有非線性的理解
     - 這是 postfix notation 所帶來的啓示
     被線性的展示給機器的數據就像是一個無序集一樣
   * 這種觀念上的轉變
     完全得益於對明顯的參數棧的使用
   * 可行性在於
     我發現了
     儘管 我所設計的新的關於函數作用的語法是畫在紙上的二維圖形
     但是 只要規定一些簡單的規則
     - 提供一些簡單的小精靈
     那麼 這些二維的圖形就可以很容易地被翻譯成一維的表達
     反之 看見一維的表達 也很容易想像出二維的圖形
   * 可以發現
     支撐樹 的好處被保留了
     - 要知道 postfix notation 和 sexp 的性質是一樣的
       只不過沒有括號而已
     而 單純地使用 支撐樹 所帶來的侷限性被消除了
** 標記語言 與 文本性編程接口的性質之匱乏
   * 標記語言 要有一般性
     在能夠初始化 λ 的同時
     還必須能夠初始化一般的有向圖
   * 但是 想要設計一種線性的語法
     以令人[令我]滿意的方式表達有向圖
     那真是太難了
     可能理論上就是不可能的
     想要以簡單的方式表達由樹生成的有向圖[正像λ這種]
     還是可以想像的
     因爲做了很多約定
     方才讓這種類型的圖得以
     被某種語法簡潔的表示
     然而
     一種語法 + 一種約定 == 一種特殊的有向圖
     不可能有萬能的語法能夠以簡潔的方式表達所有的有向圖
   * 如果如此需要有向圖處理語言
     那麼就應該用手繪的點線圖來設計相關的
     初始化語法
     還有處理函數的語法
     否則根本不能令人滿意
** 不可能
   * digrap 目前來說是不可能的
     如我之前所說
     對於有向圖處理語言來說
     其數據結構與處理函數
     可以以各種方式在各種語言中實現
     而難點在於語法的設計
     如果想要設計出
     可讀性可接受的[可被我接受的]語法
     就必須不再把設計侷限於線性的文本之內
     而使用[任何其他形式的]
     具有更豐富結構的符號系統
     作爲語法的載體
   * 也就是說我現在沒法設計出這樣的語言
     因爲[目前]
     我對語法的設計必須侷限在線性的文本當中
   * 因此
     退一步
     在 cicada 中
     我放棄對一般的有向圖[這個數據結構]的表達
     而只表達一種特殊的有向圖
     [這都是因爲我需要維護語法的可讀性]
* 一些關於明顯參數的嚴重問題
  * 在使用明顯參數的時候
    既然
    函數都是登記在數據類型中的
    那麼
    我還是必須通過指明一個主要參數
    因爲找到一個數據類型 是找到函數的前提
    如果我默認而視棧頂的第一個參數爲主要參數
    那麼我就必須得把這個主要參數調整到棧頂來
    這樣就還是需要指明參數的順序
    這樣就與 "明顯的參數名以消除參數的順序"
    這個初衷相左了
    所以
    我必須這幾一個語法
    - 增加 詞的修飾符 或 語法關鍵詞
    以明顯地指出哪個參數是主要參數
    - 我想 新增一個 語法關鍵詞 會好些
  * 我應該怎麼利用 <:x 和 x:>
    後者應該被如何使用 ??
    專門用來引入特殊的語法關鍵詞 ??
* >< 邏輯之引
** 記
   * 古典的 形式邏輯學家
     們把自己的表達方式限制爲了線性的文本
     我將袪除這種限制
     而把形式邏輯的本體 定爲
     高維的拓撲流形 和 有向圖 等等 更豐富的結構
   * 邏輯學所對應的原始虛妄是
     人類的可控之物之安全感
     只要我的理論也能提供這種安全感
     我就能易羣之所趨
** 有向圖
   * 從有向圖開始
     而有向圖中各元素所形成的維數關係
     很容易被推廣到高維
** 對組合邏輯的反思
   1. 組合邏輯在於去除 約束變元
      但是
      使用大量的約束變元 正是代數等式的意義所在
   2. 觀點是
      約束變元的使用是爲了
      讓人對思考的本體有一個印象
      這種印象能夠揭示本體的某些性質
   3. 本體是函數[運算]
      而做想要表達的性質是函數方程[運算律]
      用來形成函數方程之方程者亦是函數[算子]
   4. 使用很多約束變元
      就隱匿了本體
      所以是不好的
      [其不好在於 會引起人們思考時的混亂]
   5. 注意這裏對交換律的表達
      需要 curry
      即需要 函數一元化
      所以一元化是好的
   6. 注意對函數方程的證明
      ??? 還是需要約束變元的
      爲什麼 ?
      什麼是 證明 ??
      把邏輯也視爲算數試試
   7. 對函數的定義
      如何定義一個函數 ?
      給出這個函數的計算方式 ???
   8. 不用約束變元
      如何表達 加法交換律  ???
      我需要一個基本的
      用來表達函數的參數之間的對稱關係的東西
      然後才能表達出 類似 加法交換律 之類的方程
      比如 λxy.Mxy == λxy.Myx
      然後再把兩邊的約束變元消去
      [這種消去顯然太複雜了根本不值我演算一遍]
      重點是
      我可以給將要推導出來的組合子以名字
      然後就使用它們就行了
      k和s的意義就在於
      讓我從理論上知道了 我想要的任何的組合子都是存在的
      理解到這一點非常重要
      k和s並不爲以純粹地方式在實際的編程中被使用
      而在於用來證明
      在理論上
      有限個組合子就能代替關於代入的推演規則
      [要知道 後者敘述起來是很複雜的]
   9. 也就是我需要用一個 組合子 來捕捉這種對約束變元的使用
      [比如如果有逆運算算子的幫忙]
   10. 所以組合邏輯
       是一種[不同於最顯而易見的函數作用的]觀看問題的角度
       作爲一種新的觀察角度
       當這種角度被發現時
       發現它的人自然就有希望[野心]
       想要去觀察出別人以別的方式沒有觀察出來的東西
       當某些希望被別的學者證明是虛妄的時候
       haskell 只好辯解說 自己繼續對這個領域做研究是因爲興趣
       但是
       其實 haskell 還是沒有悟出來根本的道理
       那就在於
       去得到不同的觀察角度 這件事本身就是意義所在
       如果從很多的角度去觀察自然的某一個特性的時候
       自然的這個特性都是如此
       那麼自然的特性就是如此而已
   11. 我發現
       我可以以 "對函數的理解爲中心"
       而演繹一下各個理論的歷史
* digrap
  * digrap 的目的是
    用高維的拓撲結構來實現一個計算模型
  * 對於幾何體
    1) 編碼
    2) 編碼 以使 處理 爲可能
    3) 處理 以成 形變 之義
    4) 形變 以成 計算 之義
  * 我發現最重要的一點是
    去找到什麼幾何體適合用來形成計算模型
    這種 幾何體 需要具備的性質就是
    1) 具有較優良的可編碼性
    2) 其變換能夠被表達
       並且有豐富的性質
  * cicada 中
    對明顯的副作用的聲明 等等 相關的設計
    都是爲了實現 digrap 之用
* 正名
  * digrap == directed graph processing
    即 以有向圖爲基本數據結構的語言
  * 實現對有向圖而言的各種等詞
    1) 在以圖爲數據結構編程時
       這些這些等詞是基本工具
    2) 在實現數學形式語言時
       這些等詞是形成命題的基礎
  * 說對 λ-cal 還有對 rewrite-rules 的實現
    等價與 對圖[圖的圖]的惰性求值
    這裏這些圖的特點是什麼
    反過來問
    是什麼使得對它們的惰性求值
    可以用 λ-cal 或 rewrite-rules 來描述 ?
    是對節點和邊的標記系統嗎 ?
    [約束變元]
    每個站在一個節點上看看這個節點的標記
    再看看某一條有向邊的標記
    就能知道從這個節點沿着這個有向邊走過去的節點的標記
    [這對 cayley-graph 的使用有什麼啓示 ???]
  * note about λ-cal
    我把對 λ-cal 的實現理解爲對有向圖的惰性求值
    但是這樣作好像並不自然
    不管是在理解方面還是在實現方面都是在倒退
    因爲
    當人對一個有向圖的惰性求值形成了 λ-cal 這樣的編碼
    他就獲得了更特殊化的語義
  * 但是一般性的分析
    也許更夠引出同源的理論
  * 我把一次 -sβ-> 理解爲添加一個節點再刪去一個節點
    而他把一次 -sβ-> 理解爲把一個編碼轉化爲另一個編碼
* 記
** platonism [理想主義]
   the world of mathematics exists independently of the mind of the mathematician
   every statement that makes mathematical sense is either true or false
   [statement that makes mathematical sense are called proposition]
** brouwer [直覺主義]
   the foundation of mathematics is in the intuition of the mathematical intellect
   proof by contradiction is not an acceptable proof rule
   [因爲 用反證法所正名的存在性 有時並不能[樸素的]直覺所[容易地]察知]
** 數學語言
   1. 數學只不過是語言而已
      它也有自己的演變
   2. 最沮喪的時候 也要知道
      hott 是關於語言的學問
      因爲我已經發現
      在回到更傳統的數學活動當中時
      我的思考方式和表達方式
      已經被 λ-cal 與類型論完全改變了
      我想更深刻的改變我的認識與方法的是
   3. 對形式語言的學習
      增強了我對數學概唸的表達能力之外
      還讓我 排斥形而上的傾向
   4. 對計算理論的學習
      現在在方法上面我更注重可構造性和可實現性
** 範疇論於運算級 與 範疇論的弱點
   1. 既然我已經給出來了自由代數結構這個基礎
      那麼我關於運算級的想法是否可以用範疇論的語言來表達
      不可以
      因爲範疇論不適合用來描述具體的[構造性的]數學結構
      這就是範疇論的弱點
      [這就是 範疇論 被成爲 抽象廢話 的原因]
      要知道在最開始發展等級理論的時候
      我就是要發展彌補範疇論的這種弱點的方法
   2. 級數的升高惡化着級數升高的條件
      [使得級數的繼續升高成爲不可能 ???]
** 無窮有向圖的惰性求值
   1. 對無窮有向圖的處理只能是惰性的
      機器需要知道的是如何在需要的時候到達這個圖中的任何一個節點
      當機器已經有這樣的知識之後
      既然關於這個圖的一切已經蘊含於這些知識當中了
      我如何能表達關於這個圖的一般性質
      我現在只知道對這些性質的表達一定是在一個更高層次的語言中進行的
   2. 既然實現一個形式語言被我理解爲
      實現對一個無窮有向圖的惰性求值
      我想最適合用我的語言實現的語言應該是
      一些製作形式語言的工具
      + 首先 hott 中各種關於語言的實驗在我的語言中就方便多了
   3. 更廣泛的
      當我能方便的處理有向圖時
      因爲使用了一個性質更豐富的基礎數據結構
      在使用這個語言的時候對於很多事情都能產生新的想法
      尤其是關於計算的理論
      還有關於數學
** 設計之極簡主義
   1. 我已經知道該如何去推廣λ-cal以形成一個數學背景
      來設計我的語言的語法了
      只是還有一兩個問題沒有想通
   2. 除此之外對於理論的創造而言有一個重要的哲學觀點需要被我認同
      那就是極簡主義
   3. R5RS
      programming languages
      should be designed
      not by piling feature on top of feature
      but by removing the weaknesses and restrictions
      that make additional features appear necessary
   4. 但是我很難遵循極簡主義
      因爲我處理的問題本身的複雜性
      但是這只不過是一個藉口而已
   5. 有很多方式可以建立幾何學
      但是是歐幾里得說明我們只需要五個公理
      古代的人也許也認爲那種幾何是複雜的呢
   6. 那麼我需要作的就是看到有向圖處理的本質
   7. 但是也許我的整個計劃就是在違背極簡主義
** 關於 lazy-eval
   - k :: 什麼是lazy-eval 惰性求值?
   - x :: 就是懶得去求值的意思
        比如構造子在構造一個數據結構的時候
        構造子它就像一個函數一樣 它的參數是一些表達式
        這些表達式可以是解釋器能夠解釋的任何複雜的嵌套的東西
        比如一個表達式裏面又有很多構造子對參數的作用等等
        構造子如果是懶惰的
        你讓它構造東西的時候
        它就只作最基本的工作
        它把這些表達式放到該放的地方之後就不管了
        當你之後要需要知道構造子所構造的部分的值的時候
        你會用與構造子對應的詢問子來詢問
        這時候詢問子纔會完成求值的工作
        也就是說構造子是懶惰的
        把活都交給詢問子來幹了
        比如 LISP 中的的懶惰版本的 cons 可以叫做 zons
        (zons (λi.i λi.i) (λi.i λi.i))
        根本就不會對它的兩個參數求值
        只有當 (zar (zons (λi.i λi.i) (λi.i λi.i)))
        => λi.i
        的時候纔會對它的第一個參數求值
        等等
   - k :: 那麼
        是不是任何結構化數據的構造子都能變得懶惰 ???
   - x :: 其實我也不知道
        你可以嘗試去找找反例
        如果找不到反例
        你可以嘗試形成一個小理論
        [也許需要補充一些假設什麼的]
        去證明對你的問題的肯定是一個真命題
        但是我懶得這麼作了
   - k :: 看來根那些構造子一樣
        你也是懶惰的
   - x :: 懶惰也沒什麼不好
        另外我想指出
        對於惰性求值這個術語還能有別的理解方式
        那就是函數的惰性求值
        構造子可以被理解爲函數
        我們正是在這種理解方式下來解釋懶惰的構造子的
        函數也可以被理解爲構造子
        函數的惰性求值也有類似的解釋 我就懶得說了
   - k :: 但是至少說一說函數爲什麼是構造子 ???
        這並不顯然
        最好能給我舉一些例子
   - x :: 好的
        讓我們來考慮純粹的理論性的 λ-cal
        說它是理論性的是因爲
        雖然它能夠用來編碼你能想像到的所有數據結構
        並且它能夠用來表達所有可計算的函數
        但是使用起來並不方便 計算起來也不高效
        但是我們就先來考慮這種簡單的東西
        因爲我們想要理解到問題的本質
        首先是它的表達式的集合的歸納定義
        [或者說遞歸定義]
        #+begin_src bnf
        簡單得寫就是:
        <λ-term> ::= <var> | (<λ-term> <λ-term>) | (λ<var>.<λ-term> <λ-term>)

        分開來可以寫成:
        <λ-term> ::= <var> | <λ-application> | <λ-abstraction>
        <λ-application> ::= (<λ-term> <λ-term>)
        <λ-abstraction> ::= λ<var>.<λ-term>
        <var> :: {一個先驗定義的符號集 與自然數集等勢}
        #+end_src
        先不考慮懶惰不懶惰的問題
        這種表達式其實是二叉樹 你能看出來嗎??
        比如:
        (a (b (λx.[c (x ((x m) n))] (λi.i λi.i))))
        我用 [] 表示了那個直接跟在 λ 面的特殊的 <λ-term>
   - k :: 上面的例子真是構複雜的了
        但是我能理解
        畢竟想要存儲表達式就必須有一個數據結構
        而這裏的數據結構就是二叉樹
        並且我知道
        這個二叉樹只有葉節點是有內容的
        只要使用括號就能用線性的字符串來表達這些二叉樹
        並且我還知道
        是 <λ-term> ::= (<λ-term> <λ-term>)
        這一個歸納定義項在是形成着二叉樹
        但是 λ<var>.<λ-term> 這個東西我有點不理解
        它好像是二叉樹的簡單語義之外的東西 ??
   - x :: 沒錯
        有了它其實我們得到的就不是單純的二叉樹了
        而是一個有向圖
        這個有向圖的支撐樹是一個二叉樹
        這個支撐樹就是上面你所指出的那個歸納定義項所形成的
        而支撐樹之外的有向邊
        就是令你迷惑的那個 λ<var>.<λ-term> 形成的
        只要把 λ<var>.<λ-term> 中
        <λ-term> 裏面
        與 λ 後面的 <var> 相等的 <var>
        鏈接到 λ 後面的 <var>
        你就得到整個有向圖了
        如果我能在黑板上給你畫一下的話
        那麼不用言說你也會明白我的意思
   - k :: 我明白了
        我能想像出你所希望描述的有向圖了
        現在給我解釋什麼是函數的惰性求值吧!
   - x :: 這樣來想
        在 LISP 中用構造子 cons 來構造列表
        [LISP中的這個構造子是勤快的]
        (cons 1 (cons 2 (cons 3 '())))
        這與直接寫出表達式 '(1 2 3) 是一樣的
        而在上面我寫出表達式
        也與我用構造子來構造這個表達式是一樣的
        這裏我需要懶惰處理的是
        (λx.[c (x ((x m) n))] (λi.i λi.i))
        因爲這一項就是需要被求值的項
        它求值之後應該得到 (c (m n))
        這就是構造子懶得乾的事
        構造子和函數可以以差不多的方式來理解
        也就是說函數也可以是懶惰的
        構造子以參數爲基礎進行構造
        就類似於 函數拿到參數然後進行代入
        當函數懶得對參數求值而直接進行代入的時候就是惰性求值
        但是要注意一個參數可能被代入到多個點
        [就像上面一樣]
        這時候如果對一個點的參數求值了
        那麼其他的點就都應該知道這個被求值的結果了
        [這就叫做 call-by-need]
        這一點是對惰性求值的實現方面的問題
        想要實現這種東西並不困難
   - k :: 惰性求值有什麼好處呢 ??
        哦
        我看到了一種好處
        比如在上面
        (car (λx.[c (x ((x m) n))] (λi.i λi.i)))
        => c
        當使用惰性求值的時候
        詢問子 car
        沒有詢問到的地方就不需要被求值
        因此 (λi.i λi.i) 根本就沒有被求值
   - x :: 沒錯
        這就是 call-by-need 這個術語的由來
        更重要的是這種求值方式在 λ-cal 的理論中具有優越性
        這裏我就需要引用一些別人的書來給你看了!
   - k :: 那麼 digrap 中的惰性求值應該如何實現呢 ???
   - x :: 這個留到下次討論吧 !
* ζ-cal
** 記
   1. 也許最後我會發現我所尋找的解決辦法極其簡單
      只不過我一直沒能認清一直就在我眼前的事實而已
   2. abstraction 與 application 的意義本來就是相當廣的
      對一個 λ-application 的計算
      在 "形式" 上 需要遵循 推演規則
      推演規則應該如何施行
      其信息是被編碼在 λ-abstraction 中的
      可以說 λ-abstraction 是對 rewrite 的抽象
      一個有向圖 當這個有向圖和它的參數融合的時候
      這個 有向圖就依照編碼於這個有限圖內的信息而變化
      這種意義上的 rewrite 也可以是就更一般的有向圖而言的
   3. 我稱這種廣義的 λ-cal 爲 ζ-cal
      ζ-cal == basic-directed-graph-processing
      + ζ-abstraction
      + ζ-application
      + ζ-lazy-eval
** λ 之我見
   λ-ap 是對葉節點被自由變元標記了的
   分叉數爲2或1的樹 [有向圖]
   的遍歷
   [傳統的術語中 各種不同的遍歷方式 就被稱爲各種化簡策略]
   其中每次遍歷到 λ-ap 的時候樹就會按 <-β- 所描述的規則變化
   1) λ-ab 的形成的任意性:
      以任意一個 term 爲基礎
      然後指定一個自由變元
      就可以形成一個 λ-ab
      之後這個自由變元就變成約束變元了
      去形成一個 λ-ab
      就是去指出一個點[一個位置]
      並且聲明 這個位置的點
      將來要被換成另外的有向圖
   2) λ-ab 的局部性:
      對一個葉節點對的處理
      並不會影響這個葉節點對之外的圖的其他部分
      在推廣的過程中
      這種局部性
      是這樣被捕捉的
      即
      爲了做一個變換
      描述中 必須以被代換的點爲基準
      對別的點的指明
      都通過就這一基準點的相對位置而完成
** 類比
   1. 用鏈表來實現 λ-cal
      之後寫出複雜的列表處理的函數就全在於 λ-cal 了
      此時還需要對 rewrite [比如 -β->] 的實現
      即 一個解釋器
      [即 爲了讓 λ-ab 中能夠編碼一個代入]
      [而需要明確編碼的方式]
      + 此時需要對約束變元作技術性的處理
        要麼用重命名的方法
        要麼用用有向圖來處理
      + 反過來 λ-cal 可以完成對鏈表的處理
   2. 用有向圖處理來實現 ζ-cal
      反過來這種 ζ-cal 可以完成對有向圖的處理
      之後寫出複雜的有向圖處理函數就全在於 ζ-cal 了
      + 有了這層語義
        就算是對有向圖這種複雜數據結構的處理
        也能使用函數式編程範式了
   3. 類比還在於
      我能把 λ-cal 包含在 ζ-cal 之內
** ζ-cal 作爲 λ-cal 的推廣
   1. 下面的理解最重要
      應該把 λ-cal 也理解爲一個對二叉樹的惰性求值系統
      [用樹來考慮下面的東西]
      尤其是考慮到絕對的自由變元時更應該如此
   2. 那麼這種惰性求值系統的特點是什麼呢 ???
      有所謂的惰性求值之後
      就能用有限的元素來表達無窮的結構
      [這種性狀最令人感興趣]
      這是因爲對與這種圖
      人們規定了一種特殊的遍歷方式 即 -β->
   3. 並且要知道 一個 term 是不是 λ-abstraction 都沒有關係
      對 λ-abstraction 內部的東西也是可以進行求值的
      λ-abstraction 並沒有特殊性
   4. 難點在於
      當遍歷到一個 λ-application 時
      它本身與周圍的圖的鏈接方式是平凡的
      它求值之後所得的東西與周圍的圖的鏈接方式也是平凡的
      但是對與一般的有向圖這一點並不成立
   5. 這裏的複雜性可能是本質的
      也就是說 ζ-cal 必須描述兩種鏈接方式
   6. 但是如果有局部性的話
      如何呢 ?
      整個式子 ((ζ <body>) <arg>)
      是以某種方式嵌在一個被遍歷的大的圖中的
      <body> 與外面的大圖的鏈接方式是已知的
      而 <arg> 被代入 <body> 所改變的東西
      邊並不影響 <body> 與大圖的鏈接
      這就是局部性
   7. 但是又回來了
      即 這樣就沒法把 (ζ <body>) 當作一個獨立的東西了
      只有當指明了 <body> 與大圖的鏈接方式的時候
      (ζ <body>) 纔有意義
      或者 (ζ <body>) 可以被當作獨立的東西
      但是每次被放入大圖中的時候都必須說明 <body> 中
      沒有被 ζ 的抽象所影響的部分如何與大圖相鏈接
      沒錯
      這是合理的
      因爲
      在有向圖處理中
      擴大一個圖就是去說明一些複雜的鏈接方式
      這樣一個重大的問題就解決了
      [可以說就幾何直覺而言現在已經沒有任何難點了]
      還有一個重要的問題就是形成遞歸
      這將是要在下面提到的
      即 形成具有無窮性的結構[比如遞歸]
      其本質不在於巧妙的 term
      而在於自我引用
   8. 在有向圖處理中
      在一個需要惰性求值的點處對原圖的其他部分的引用也是可以想像的
      + 畢竟λx.F(xx) λx.F(xx)之所以能形成遞歸對遞歸函數的定義
        是因爲前面的λ-abstraction作用於與自身相同的λ-abstraction
        或者說前面的λ-abstraction在作用於自身
      類似於分形的圖是經過無窮次的遞歸得來的
      因此就與fixed-point有關
      因此也與遞歸有關
      + 考慮Y所生成的遞歸函數作爲無窮二叉樹的性質
        那也是分形
        因爲那是在-β->的特殊指引下自身在引用自身
        這就是分形的本質
        也是那些正規的無窮圖的本質
** 對圖的基本處理
   有以下基本操作
   [其實 ζ-cal 本身就也是被基本的有向圖處理實現的]
   1. 利用樹來初始化一個圖
   2. 將兩個圖用一些新的有向邊相連
   3. 刪除某些節點
   4. 刪除某些邊
   5. 改變某個點或邊中所存放的東西
      點和邊裏是可以存放東西的
      而且沒有類型的限制想存放什麼就存放什麼
      就像 lisp 的 list 能夠保存任何類型的數據一樣
      我需要我的有向圖也有能力保存任何東西在裏面
** ζ-abstraction (ζ-ab)
   對於一個圖 指定其中的一個基點
   1. 以這個基點爲基礎
      用一棵樹來指明一個有序節點列
      這個有序節點列是爲之後的 "擴大" 所準備的接口
      當這些接口被拼接時這個圖會被擴大
   2. 以這個基點爲基礎用一棵樹來指明一些將被刪除的節點
      這樣會使這個圖縮小
   3. ><><>< 那麼其他的對圖的操作如何呢???
      這就是所有的操作嗎???
   4. >< 可以變大可以變小我就掌控了所有的變化 ??
   5. 所列出來的兩個點列中
      哪些點會被刪除或者哪些點會被鏈接
      都是要等到ζ-application的時候纔會被明確的
   6. 整個ζ-abstraction也是一個特殊的圖而已
      只要使用從一點出發的一些有向邊來指明一次抽象中的
      接口節點列和所能刪除的節點列 就行了
      這樣我就可以利用 ζ-abstraction
      把某一類 有向圖處理抽象出來
   7. 一個ζ-ab作爲一個gexp
      就像一個小機器一樣
      在ζ-cal的語義中它以其中被抽象了的點爲接口
      對於一個ζ-ab(as gexp)我可以實現一些基本的函數來查看它作爲機器的性質
      比如:
      1) 詢問這個ζ-ab中所有被抽象了的點
      2) 詢問一個點的接口點列和可刪除點列
      3) 等等
      4) 這些詢問所返回到的信息應該能直接被ζ-ap中的ζ-con利用
** ζ-application (ζ-ap)
   這時候我手上有兩個ζ-ab
   就像我知道一個函數(λ-abstraction)的性質一樣
   + 函數的:參數個數與類型 返回值個數與類型
     其中個數不是本質的類型纔是本質的
   在這裏我也知道ζ-ab的性質:
   1. 它所能刪除的點列
   2. 它的接口點列
   一次ζ-ap就是:(注意只有兩個ζ-ab才能被作用)
   ζ-ap == (ζ-ab ζ-con ζ-ab)
   其中ζ-connection是對連接方式的描述
   + 注意這看起來是對稱的
   ζ-ap也是用一個圖來表述的
   這樣一個ζ-ap的結果就可能是一個新的ζ-ap
   + 對ζ-ab的處理就是一個需要類似於解釋器的東西的地方!!
   + 雖然不是類型系統
     對接口與連接方式的匹配的要求
     同樣也是對函數的輸入與輸出的限制
     也許引入適當的語義
     我就能以這種方式給出一個類型系統的模型
** 也就是說 融合 函數 在語法上被優化爲了一個中綴表達式
** >< ζ-lazy-eval
   1. 這是很樸素的想法
      即上面的ζ-ap是真正被遍歷到的時候纔會被進行的
      因爲ζ-abstraction也是用一個圖來實現的
      所以這種lazy-eval很容易實現
** >< 關於嵌套與自我引用
   1. 其實也很簡單
      ζ-ap的嵌套是自然的
      一個ζ-ap的結果就可能是一個新的ζ-ap
      它使得對某個圖的遍歷方式變得複雜
   2. 而自我引用就是沿着新的邊走卻又走回了原來的節點
      這些一起使得可以形成複雜的無窮圖
** >< 關於透明性
   所謂透明性就是把ζ-abstraction於ζ-application都表示成有向圖
   這樣我可以完全剔除約束變元
   而解釋器對ζ-cal的實現就是有向圖處理
** 關於代數
   1. 一般的代數結構自然的會形成二叉樹
      但是這其實並不是不可能
      考慮一下高維同論羣就知道了 !!!
      [其羣也爲代數 但是是變換的複合]
   2. 考慮跟 λ-cal 有關的豐富的數學理論
      範疇論 代數拓撲 等等
      可想而知 ζ-cal 這種計算模型
      其背後所隱含的數學理論是非常新而豐富的
   3. 比如我可以嘗試先在 λ-cal 的圖論意義
      和 λ-cal 的代數意義之間建立一種關係
      然後再利用這種關係從 ζ-cal 的圖論找到 ζ-cal 的代數意義
   4. 其實當說代數意義的時候
      函數的複合 和 函數的作用
      這兩種東西的區別造成了很大的差異
      其實本質上是一樣的
      只不過函數複合直接用 threaded-code 就能實現
      而函數作用還需要複雜的編譯而已
      二者都可以實現 lambda 所代表的代入語義
   5. 但是
      其實
      二者都沒什麼代數可言
      因爲作爲代數它們的性質都太一般了
      [除非作出某些限制]
      然而
      人們已經指出了
      其 與 範疇論 邏輯 拓撲 這三個學科之間
      都有有趣的聯繫
   6. 但是這幾乎是不可能的
      因爲在進行一個 ζ-ap 的時候
      我不光只需要那兩個 ζ-ab 而已
      我還需要一個額外的東西來指明這兩個 ζ-ab 如何相鏈接
      這已經出離一般的代數結構之外了
   7. 其實沒那麼可怕
      因爲在新的代入語義中
      明顯的指明參數名字的過程
      已經類似於一個被參數化的中間元了
   8. 但是也沒有出離的太遠
      畢竟這是不過是
      (ζ-ab ζ-con ζ-ab) -> ζ-graph
      [ζ-graph == gexp]
   9. 但是
      既然如此
      其實代數意義就已經喪失了
   10. 如果只是在遍歷圖的時候其中的一些部分被惰性求值
       那麼如何觸發一次 ζ-ap 的進行 ??
       這一點還沒想清楚
       完全的惰性求值就沒有這種顯式的觸發
       也許增加一個可以控制 ζ-ap 的觸發的機制
       我就能實現對求值時間的控制
   11. 如果我固定一種[或某些] ζ-con
       並且將 ζ-ab 一一定那個的方式封裝起來
       我就很容易回到一種代數語義
       [所以這是代數的推廣]
       [只不過算數元素之間的 "乘法" 在這裏被豐富了很多]
       比如利用上面的方法我可以回到 λ-cal
   12. 上面的行爲
       就像是去約定一個默認的函數作用順序一樣
** 再次回到基本操作
   1. 顯然只要基本操作不改變ζ-ab中的接口點列中的點
      那麼任何操作都是合法的
      也就是說ζ-ab是可以被基本操作來作用的
      它們跟一般的圖沒什麼區別
   2. 基本操作甚至可以形成手術
      來改變描述ζ-ab中的接口點列和可以被刪除的節點列的有向邊
      這就是透明性所帶來的好處
      任意一個用圖描述的圖的算法
      都是一個圖而已
      可以很容易的拿出來修改與考察
** 新編程範式
   1. lisp 的特點是
      用鏈表處理 實現 lambda-演算
      而 lambda-演算
      很適合反過來 用來實現對複雜的鏈表處理函數
   2. 其實
      lambda-演算之語義 與 其實現方式 是無關的
      比如
      只有包含約束變元的 lambda-term [組合子]
      就單單表達一個作用於 lambda-term 的算法而已
      當 增加原子性的 數據類型 和處理函數的時候
      含有自由變元的 lambda-term 就可以
      用來處理各種 數據類型 的數據
      lisp 找到了完美的平衡點而已
   3. 這對 digrap 的啓示在於
      ζ-cal 是用 directed-graph 這個數據類型
      來表示處理 directed-graph 的算法
      directed-graph 的點和邊中可以包含其他類型的數據
      對其他類型的數據的處理用 原子性的 primitive 函數 來完成
   4. 問題是這兩種類型的函數如何相互協調
      在 lisp 中 primitive 的作用方式與 λ-ab 的作用方式是一致的
      慶幸的是
      新的 爲 cicada 而設計的 函數作用的語法
      其作爲將來的 [相對 digrap 而言的] primitive 函數
      已經具有相當一致的作用方式了
   5. 其實在這裏我已經形成了一個
      比 以 λ-cal 爲核心的函數式編程範式
      更 豐富的一種編程範式
   6. 看看一個 ζ-ap 的樣子 (ζ-ab ζ-con ζ-ab)
   7. 而每個對於 gexp 的操作
      [比如一個基本操作或者一個 ζ-ab]
      都可以有兩個版本
      一個使用被處理的圖本身[通過地址]
      一個使用新複製的一個被處理的圖
      這樣一個第二個版本的 ζ-ab 就可以像數學中的函數一樣
      在多次的作用中維持一致的行爲
      這就是我所繼承的函數式編程範式的基因
   8. 去證明我確實形成了新的編程範式
      就在於
      用我所設計的模型
      來表達各種其他的基本的計算模型
      比如
      1) 利用 ζ-cal 來實現 λ-cal
      2) 利用 ζ-cal 來實現遞歸函數
      3) 利用 ζ-cal 來實現類型系統
   9. 首先既然 λ-cal 被理解爲是
      用有向二叉樹表達的對有向二叉樹的操作
      那麼用 ζ-cal 來實現 λ-cal 是非常簡單的
      也就是說 ζ-cal 的抽象能力顯然比 λ-cal 更大
      但是也更複雜
      因爲使用了結構更豐富的數據結構
      所以我的計算模型一定可以
      以更簡單的方式
      去表達一些
      用 λ-cal 和其他計算模型表達起來更複雜的計算
   10. 何爲計算
       在我的語言內
       計算竟被理解爲用圖表達的對圖的操作
       把這個問題追問下去很可能令人陷入瘋狂
   11. 函數的階
       在 digrap 中函數的階的樣子很不一樣
       可以把一個 gexp 中的被抽象了的點的個數定義爲方程的階
       但是這些點之間是平行的關係
       所以 階 這個詞 所暗示的序關係其實是錯誤的
** >< 何謂用圖來表示對圖的操作
   1. 即對圖的遍歷方式有兩類
      一類是按語法遍歷[數據]
      一類是按語義遍歷[運算]
   2. 按語義遍歷就是說 像((λ ***) ***)節點對一樣被<-β-處理一樣
      這樣我就能夠把ζ-abstraction在圖中利用其它ζ-abstraction的作用來代來代去
      然後形成ζ-ap
      ζ-ap的返回值可能還是ζ-ap
      [有一步的-ζ->和多步的-ζ->]
      [即我能控制求值的方式]
      我的圖的表達式中也要有匹配到某種模式的圖被按語義處理
      這需要一些設計 但是簡單的
      重點是所有這些必須都用有向圖處理來實現
** >< 例子 [需要更多的例子]
   對那個無窮五星圖
   遍歷到中點的鄰點時需要把中點代換爲一個五星
   然後把代入的五星與原圖相連
   這就是用惰性求值的ζ-ap來實現的
   但是完全自我引用就會形成循環
   所以對自我引用應該至少提供兩種處理方式
   1. 一種會形成真正的新的節點
   2. 而另一種不會
   對於形成真正的新節點者
   自我引用是假的
   自我引用只是提供了一個和自己相同的模板來擴大這個圖
** >< 打印
   我需要對文件的結構化讀寫 這裏有是一個新的設計領域
   >< 打印可以用支撐樹來作嗎?
   圖中也許必須包含一些額外的信息來建議如何把一個圖打印出來
* ^-^
** Y
   1. 假 Y
      #+begin_src cicada
      [ [ :x (:x) (::f) ] <x
        ( :x (:x) (::f) ) ]
      #+end_src
   2. 這種語法的特點是
      局部變量的使用方式間的區別變得很搶眼
   3. 而兩種括號的語義在於
      #+begin_src cicada
      (* 有名函數的作用 *)
      (function-name)  ==  function-name (apply)

      (* 匿名函數的定義 [數據結構的初始化] *)
      [ :x (:x) (::f) ]

      (* 匿名函數的作用 *)
      ( :x (:x) (::f) )  ==  [ :x (:x) (::f) ] (apply)
      #+end_src
   4. 也就是說
      用默認的 [ ] 來初始化基本數據的時候
      我提供了一種標記語言來說明局部變元的作用範圍
      1) 這種標記語言是利用 相對位置的
         而 傳統的 表示約束變元作用範圍的 標記語言
         使用的是 label
      2) 使用 label 就相當於
         在進入函數體之前
         對 被認爲是這個層次的 約束變元 進行聲明
         兩種方法個有用處
         所以我設計語法 把它們都實現出來
      3) 想要改變默認的 [ ] 的行爲的話
         就可以 使用
         [ <hiya> ] [ <lazy> ]
         [ <do> ]
         [ <re> ]
         [ <mi> ]
         [ <fa> ]
         [ <sol> ]
         [ <la> ]
         [ <xi> ]
      4) 無名函數的作用也被優化爲了 ( )
         這樣在視覺上就與 (function-name) 一致了
   5. Y 的使用方式是
      #+begin_src cicada
      <f Y apply
      <f (Y)
      #+end_src
   6. 真 Y
      #+begin_src cicada
      [ [ [ ::x (::x) ] (::f) ] <x
        ( [ ::x (::x) ] (::f) ) ]

      [ [ [ ::x (::x) ] (::f) ] <x
       ([ [ ::x (::x) ] (::f) ]) ]

      [ [ [ ::x (::x) ] (::f) ] <x
        [ [ ::x (::x) ] (::f) ] (apply) ]

      (* 對比如下 *)
      [ [ :x (:x) (::f) ] <x
        ( :x (:x) (::f) ) ]
      #+end_src
** 惰性求值
   1. 在理論性的 lambda-calculus 中
      惰性求值是自然的
      而在 蟬語 中
      惰性求值是不自然的
   2. 這就說明 蟬語 的語義
      與 [理論性的]lambda-calculus 的語義
      之間有差別
   3. 這這個差別就在於
      蟬語 對求值順序[運算順序] 有一個明指
** 登記
   1. 關於登記
      不要 簡單的 單一的
      函數小名 到 [一個]數據類型的這種登記了
      而使用複雜的類似數據酷的東西
      每個函數的作用方式被存儲起來 有待匹配和查詢
      [這裏可以實現非常靈活的設計]
      這樣在 使用明顯的參數名做函數作用的時候
      我就能夠簡化語法 ^-^
** >< 關於把 digrap 與 cicada 融合
** 冒號
   1. 前冒號用於標記約束變元
      後冒號用於聲明域
** 默認的函數作用方式
   1. 只要找到一個簡單直觀的方式
      給連在所指定層次的
      所有 約束變元 所組成的集合
      以序關係就行了
   2. 深度優先遍歷這個只有葉節點有名字的樹就行了
      此時約束變元的順序
      就是直觀的順序
** 實現細節
   1. 現在應該討論實現細節了
      因爲我已經明確了語法的設計原則
      即 我所設計的其實是一種標記語言
   2. 在我看來 標記語言之作用在於
      在線性的文本中 表達非線性的結構
      然而
      比如說 去給數據增加屬性標籤
      也稱爲標記語言 但是後者簡單的多了
   3. 我必須推廣我的設計
      使得 對約束變元的處理
      只是這個標記語言的一個應用而已
   4. 如果我使用 label [貼在殼子上面的]
      而又允許 label 重名
      那麼我就又必須去計算 scope
      計算 scope 並沒有什麼不好
      只要有明確而簡單的規則就可以了
   5. 古典的對 scope 的計算
      其實是在用大剪刀修建一個樹
      在每個計算點
      所需要鏈接的點是它的很多的子節點
   6. 現在這裏有一種優越性了
      即 在每個計算點
      所需要鏈接的點只有一個
   7. 那麼我現在能夠把點鏈接到各種殼子了
      但是其實每個有地址的東西都應該可以被相互鏈接
   8. 其實還是形成樹的結構
      但是當某些殼子被命名了之後
      - 其實不光是殼子
        殼子中的東西所自動獲得的序關係
        也可以被利用起來
      我就可以利用這些命名
      來用相對路徑
      形成對位置的指定
      - 這就說明了
        在語法解析的時候
        我必須先把樹建立起來
        然後在遍歷它 以處理約束變元
   9. 可行性已經受到了思想實現的檢驗
      剩下的就是去設計 語法 和 數據結構 了
   10. 語法
       現在能想像到的[有待優化的]對情況的分類爲
       1) 約束變元
          即 鏈接無名的殼子
       2) 鏈接到有名的殼子
          當命名具有唯一性的時候 很好處理
          但是當命名沒有唯一性的時候
          有兩種辦法
          1. 用明顯的路徑語法
          2. 做約定 [像古典的約束變元一樣]
       3) 鏈接到殼子中的東西
          1. 利用序關係
          2. 利用殼子中的東西的名字
   11. 上面的複雜的分類必須被簡化
       必須找到折中的設計
   12. 數據結構
       以雙向鏈接的鏈表爲主
       需要的時候可以增加元數據
   13. 是否以帶名字的雙向鏈接的鏈表爲主呢 ?
       把不帶名字作爲帶名字的特殊情況
   14. 上面的 侷限性在於
       每個點只能夠鏈接到一個殼子
       而一個殼子能夠鏈接到很多點
       這是約束變元的語義所決定的
       但是
       我不應該把這個
       用來初始化有向圖的
       標記語言的性質限制與此種語義
       我應該保持雙向鏈接性
       應該保持對 多點鏈接的處理能力
   15. 但是回來考慮基本的語義
       看看爲什麼這種推廣如此困難
       1) 細胞
       2) 大量的無名邊
          排斥了以前對數據結構的設計
** curry
   1. 區分 (apply) 和 (curry) 就行了
      每次 (curry) 都保證進行一次參數的綁定而返回新的函數
      也就是說只能 (curry) 所返回的
      只能是函數 不能是作用
** >< 細胞語義
   * 只要在函數的作用條件上做手腳
     我就能實現很有趣的語義
     就像神經細胞一樣
   * 函數作用的條件可以從參數到齊變爲[更複雜的條件]
   * 這裏消息傳遞的語義是明顯的
     如果每個函數都有自己的參數棧[細胞液[因爲參數的無序性]]
     參數的製備可以用消息傳遞來實現
     而 (apply) 和 (curry) 也是消息而已
   * 這裏有本質上的困難嗎 ?
     我記得我之前排除過這種語義
     而現在我又想回到這種語義
** 喻
   * 如果能形成對 語義的生動比喻就好了
   * 與物質結合而變異的生物體 邪
** 再 Y
   1. 其實重點在於自我引用
      而難點在於一般的 lambda-calculus 的語義
      並不能直接形成自我引用
      必須藉以更高層次的 組合子
      作用於一個爲了自我引用而模板化了的 lambda-function
      方才能夠形成帶有自我引用的 lambda-function
      這就是典型的
      沒有困難 製造困難 也要上
   2. 我的標記語言應該完全摒除這種弊端
      ::x 是說 這個名字叫 x 的約束變元鏈接到向外的第二層的殼子上
      很容易看出
      相反地 在殼子內引用外層殼子的語法語義也是很容易設計出來的
      並不必使用 Y 之類的東西
   3. 辨 Y 之用
      #+begin_src cicada
      (* 之前是以下面的 Y 作用於 f 的自我引用 而形成一個遞歸函數 *)
      Y
      [ [ [ ::x (::x) ] (::f) ] <x
        ( [ ::x (::x) ] (::f) ) ]

      [ [ [ ::x (::x) ] <rec (::f) ] <x
        ( [ ::x (::x) ] <rec (::f) ) ]

      (* 如此 *)
      f (Y)

      (* 而 f 如此 *)
      [ [ :arg1    <body1>  <arg1
          :arg2    <body2>  <arg2
          (::rec)  <body>
          :arg1 :arg2  <bod3> ] ]

      (* 或可用 curry 來實現 f *)
      #+end_src
      可見 f (Y) 並非 方程 x (f) = x 的解
      這是顯然的
      因爲要知道 f 必須是多元的
      才能用以形成常用的遞歸函數
   4. 而用標記語言
      比如下面的語法就能形成對殼子的引用
      #+begin_src cicada
      [ :arg1  <body1>  <arg1
        :arg2  <body2>  <arg2
        (:)    <body>
        :arg1 :arg2  <bod3> ]
      #+end_src
   5. 其中 :arg1 是從裏面鏈接一條邊到外面的殼子
      但是這條邊的目的和實現方式還是不明白的
      現在我就來明確這裏的實現方式
      也就是設計出這個數據結構
      然後再說明如何在殼子內形成自我引用
      注意 這裏內層的函數作用會進行參數綁定
      而這種參數綁定不能破壞外層的參數綁定
      因爲在最後一個 <body> 中還可能有對之前綁定的參數的引用
   6. 古典的對棧的使用方法能夠解決這個問題
      因爲不用處理參數到名的綁定
      所以非常簡單
   7. 也就是說
      與參數到名的綁定相關的信息
      必定不能被存儲在函數體的內部
      函數體本身所保存的只是算法而已
      但是這樣就不是在用有向圖來實現參數綁定了
   8. 解法是用鏈表來實現棧
      並且給每個函數的每個參數都分配一個棧
   9. 注意主要的參數棧還是存在的
      函數在作用的時候
      還是要從主要參數棧中取參數的
   10. 每個函數操作處理參數的方式是 (apply) 所完全不知道的
       它只是觀看當前的信息
       然後在數據庫中匹配以查找需要調用哪個函數而已
   11. 每個函數有一個函數頭
       這個函數頭就是殼子的語義
       其中保存了別的點鏈接到它的信息
   12. 注意這裏對數據結構的設計必須還要適應別的使用方式
   13. 每次對據的代入只是向主要參數棧中放入一個值而已
   14. 每個函數體中的每個參數都必須用一個棧來實現
   15. 在函數調用的時候
       已經放到棧中的參數應該如何被處理呢
       其中
       1) 需要被入函數的局部棧的
          1. 有名的
          2. 無名的 被以默認方式處理的
       2) 不需要被入函數的局部棧的
          1. 無名的
   16. 也就是說一定要有不需入棧的值存在
       否則就是有名者了
   17. 可以發現
       因爲要維護各種函數作用時處理參數的方式
       所以設計上有很大的不一致性
       這種不一致性給實現帶來了很大困難
   18. 所需要實現的效果是
       在很多情形下
       都能使用類似 forth 的無名方式來處理參數
       而在需要的時候有能力能夠形成有名的約束變量
   19. 先不論 (apply) 如何判斷應該調用哪個數函數
       假設我已經知道了在這種條件下應該調用哪個函數
       那麼當這個函數作用的時候
       假設只有棧的頂端的值才能被認爲是需要被處理爲局部變量的值
       那麼
       也就是說我還是必須擺好棧中的參數
       這並沒有什麼不應該的因爲棧中的參數總是應該被擺好的
       只是在約束變元的幫助下有些參數的順序如何都可以而已
       那麼我就在這裏施加一個重要的限制
       即 需要被綁定爲約束變元的值
       必須被放到棧頂
       它們在函數作用時最先被處理
       而棧中後面的值可以是以古典的 forth 的方式被處理的僞局部變元
       對於每個函數而言
       這前面的需要被綁定的參數的個數必須是固定的
       這樣
       在進行綁定的時候
       因被聲明爲了默認情況
       而可以沒有名字的參數 也就都能被正確處理了
   20. 另外一個可能的限制是
       如果有無名者那麼就必須都是無名者
       而不能混合
       這樣判斷就簡單多了
       只要棧頂是無名參數
       就按默認順序綁定它們
       而如果棧頂是有名參數
       就按參數名字來綁定它們
   21. 除非特殊聲明否則參數順序由深度有限的遍歷計算出來
* 規則
  * 新的語法已經可以想像了
    但是應該如何介紹其語法規則
    卻不是明顯的
  * 相當於 lambda 和 apply
    被定義爲了兩個 borderfix notation
    以 [ ] 爲 lambda
    以 ( ) 爲 apply
    不考慮 ( ) 對 ([ ]) 的優化了
    因爲會影響理解
  * 注意
    x 是 symbol
    (x) 是 symbol 所對應的函數的 apply
    也就是說 apply 能夠作用於兩種數據類型
    一種是 symbol 一種是 lambda
  * 然而
    ( ) 對 ([ ]) 的優化
    也可以被看成是
    apply 作用於多個 symbol
    這是合理的嗎 ( fun fun ) 之於 (fun) (fun)
    這是不合理的
    因爲在匿名函數的函數體 [ fun fun ] 中
    fun 是 symbol
    而 [ (fun) (fun) ] 中
    才是作用
    所以避免這些優化而回歸到最簡單的語義
  * 但是要知道
    對 symbol 的單獨使用
    可能根本沒有對函數作用的使用次數多
    那麼這種語法真的是設計良好的嗎 ?
    加之
    括號中所包含的只能是一個 symbol
    且不以 ( ) 來優化對無名函數的直接作用
    即讓 ( ) 成爲只能作用於 symbol 這個數據類型的
    borderfix notation 的 一元函數
* 難點
  1. 函數的返回值是一個函數
     而這個函數需要被直接作用的時候 應該如何 ?
  2. 也就是匿名函數的作用 應該如何 ?
  3. 只要這樣
     #+begin_src cicada
     (* 不用下面的 *)
     [ [ [ ::x (::x) ] (::f) ] <x
       ( [ ::x (::x) ] (::f) ) ]
     (* 而用 *)
     [ [ [ ::x (::x) ] (::f) ] <x
       { [ ::x (::x) ] (::f) } ]
     (* 或用 *)
     [ [ [ ::x (::x) ] (::f) ] <x
       [ [ ::x (::x) ] (::f) ] (apply) ]
     #+end_src
  4. 即
     { } --> [ ] (apply)
     ( ) --> [ ] (apply) (apply)
     即後者是先求值再代入
  5. 但是
     apply 是自戀的
     (apply) --> [ apply ] (apply) (apply) --> apply (apply)
     所以需要說明的是其實只有當多個東西在 ( ) 中時
     才需要 上面的規則
  6. 其實需要對什麼時候使用什麼規則有更細緻的規定
     [ ] (apply)
     就是在進行代入
     而
     symbol (apply)
     當 symbol 是 non-primitive 類型的函數的時候
     又將便會 [ ] (apply)
     當 symbol 是 primitive 類型的函數的時候
     就找到了遞歸的基本步驟
  7. 這樣
     在理論上[理解方式上]
     就把所有 bar-ket 都劃歸到了 [ ]
     而 y (x (K)) = x
     這樣的公式就得到了一致的解釋
  8. 但是這樣就使用了三種邊界
     想要在紙筆畫的圖中區分這三者
     就必須要使用不同的顏色的邊界了
     - 而 之前的設想是使用光滑的邊界和多邊形的邊界
       現在線性的文本中的語法是以 apply 爲核心而推導出來的
       但是其要求是在圖像中根本不出現 apply
  9. 這一切都是因爲 y (x (K)) = x 的出現
     其特點是 K 是純粹 curry 的
     就算用最初設計的圖來表示的話
     圖也將對應爲 y x (K) (apply)
  10. 難道 apply 也應該被實現爲以中綴表達式 ?
      不
  11. ( ) -> [ ] (apply) (apply)
      只對返回值個數爲一的函數體時才有良好的語義
  12. y x (K) (apply)
      x (K) y ()
      即 () = (swap) (apply)
      或
      x (K) y (0)
      即 (0) = (swap) (apply)
      這樣 圖畫 與 線性表達式
      在 性狀上 就統一了[接近了]
      並且注意這裏計算(apply)的兩個參數的順序不同
  13. 並且
      y ( x (K) )
      y [ x (K) ] (apply) (apply)
      y x (K) (apply)
  14. 但是都是對一元函數才好用
      或許可以 不用 (0)
      而區分 (1) (2)
      以代表返回的函數的參數個數[swap所跳過的值的個數]
      x3 x2 x1 (F) (apply) (apply)
      x1 (F) x2 (1) x3 (1)
      這都是在用默認的參數順序來進行處理
      之撐不住的時候
      也可以使用參數名字來打亂順序
  15. 發現了一個特點
      即在圖中
      箭頭和圓圈所能表達的只是單一層次的作用而已
      即 爲了 (F) 而設計的
      ( ) -> [ ] (apply) (apply)
      這種變換在畫圖的時候是絕對用不上的
      這種變換是爲了在線性代碼中
      去表達 返回值是一個函數的函數設計的
  16. 也就是說在畫圖時
      大的圓圈是 {}
      小的只圈住一個 symbol 的圓圈是 ()
      並且這種解釋對於與約束變元 (:x) 也成立
  17. ><><>< (:x) 這個小殼子也算殼子嗎 ?
      如果算的話
      點點就太多了
      #+begin_src cicada
      [ [ [ ::x (:::x) ] (:::f) ] <x
        [ [ ::x (:::x) ] (:::f) ] (apply) ]

      [ [ [ :x (.:x) ] (.:f) ] <x
        [ [ :x (.:x) ] (.:f) ] (apply) ]

      [ [ .x (:x) (.:f) ] <x
        ( .x (:x) (.:f) ) ]
      #+end_src
  18. 那麼
      y (x (K)) 應該被蟬語的線性語法接受嗎 ?
      能接受
      只要寫成 y ( x (K) ) 就行了
  19. 要知道
      所有的組合子都是一元的因此
      上面的爲組合子而設計的語法其用性有限
      在討論組合子的時候發現
      在這種語法下
      1) 等量可替換
      2) 而括號要小心使用
         因爲每個括號都是函數都是函數
      3) 並且空格被作爲了一個
  20. 重要的是
      我可以以棧處理
      還有鏈表這個數據結構
      爲語言的具體模型
      以這個具體的模型爲基礎
      證明對表達式的各種變換的正確性
      並且所有的表達式的語義
      都因我的具體模型而變得顯然
* 跟函數有關的術語的設計
  * 我發現
    只要統地使用下面的術語
    就能以一致的方式來敘述並理解
    各種語言的語法的設計
    函數的
    * 作用
    * 製作
    * 綁定
    * 定義 就是 製作 加 綁定
    每一詞 都有語法和語義連個方面
  * 其實 指稱語言學就是爲研究程序語言而產生的
    即研究文本到語義之間的對應
  * 每個解釋器語編譯器就是指稱
    它們的特點都是
    當遇到各種表達式的時候
    執行各種操作
    解釋與編譯可以被統一地理解爲指稱
    編譯器可以被理解爲特殊的解釋器
    而一般的解釋器可以被理解爲編譯之後馬上調用
  * 也就是說每一個指稱都是一個解釋器
    這種思路是爲了以具體的方式來理解指稱
* 關於線性文本與有向圖
  * 邏輯學家和數學家 之所以用 線性文本 來限制自己的表達方式
    而不使用 有向圖
    是因爲他們沒有能力給他們自己設計的數學語言寫一個解釋器
  * 而我們現在之所以沒有以有向圖有基礎的語言
    是因爲有能力寫解釋器的程序員不懂數學
* 關於編輯
  * 省略了括號 就不方便
    以 sexp 爲結構的 對代碼的編輯
  * 發現
    其實在 shen 優化 lisp 的語法
    而去掉很多括號之後
    對代碼的編輯反而變得不方便了
  * 在蟬語中
    在編輯標記語言的時候
    因爲其語法元素的語義跟語境高度相關
    所以可能會影響對代碼的結構化編輯
    複製一段代碼后
    因爲 這段代碼所處在的語境改變了
    因此 就要修改代碼內的很多瑣碎細節
    以保存所希望的語義
    除非在這幾標記語言語法的同時
    設計用來進行對代碼的結構化編輯的輔助工具
    否則就是壞的設計
  * 但是其實不是這樣的
    因爲要知道
    這是所有的擁有約束變元的語言所面臨的問題
    而相反在蟬語中
    因爲很少使用名字
    所以所需要更改的地方有時反而會減少
    也就是說要看需要被結構化編輯的代碼
    具體是什麼
    當需要更改的是層次結構時
    蟬語就是劣勢
    當需要更改的是名時
    蟬語就是優勢
* 語法
  * 可擴展的邊綴表達式
  * 雙向連接鏈表
  * 有限功能的有向圖標記語言
  * 約束變元
    [ .x ]
    把函數體中的點連接到函數的殼子上
  * 遞歸調用
    ><><><
    無名的 有名的
* 實現
** 函數作用
   * 可以發現在這樣的實現方式下
     能夠作用於不同數據類型的一個函數
     作爲雙向連接的鏈表
     在內存中只被保存了一次
     也就是說函數是對計算方式的表達
     [其實能不能作用於多個數據類型並不是重點
     重點在於這裏的觀念會影響實現方式]
   * 某個函數作用於某些數據時
     這個函數
     不是
     一個具有內蘊性的個體
     其內蘊的個體再與數據相結合而完成一個變換
     而是
     對變換的編碼
