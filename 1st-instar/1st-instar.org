#+TITLE:  1st-instar of cicada-nymph
#+AUTHOR: 謝宇恆 / XIE Yuheng
#+EMAIL:  xyheme@gmail.com

* todo
* ===================================
* note notation
** jo & jojo
   * use "jo" to denote bead
     and use "jojo" to denote a thread of beads
     [which reads like "珠珠" in Chinese]
* note intro
** indirect-threaded-code interpreter
* note different from re-designed cicada-language
** simplifications are for teaching purpose only
** no mixfix-notation
   * function call is "function" instead of "(function)"
   * no such thing like
     1 2 (add) = 1 (add 2) = (add 1 2)
** no named local argument
   * thus no inited local argument
** no title-name-table
   * and single name space
** no type
   * no type inference
   * no dynamic type tag
   * no static type declaration
** global linked-list for naming
   * not hash-table
** no dynamic-memory-management
   * no garbage-collectior
** about comment
   * the comment of the argument & return value of function
     is allowed to be written in free style normal comment
* note syntax & semantic
** compiler
   * a macro is a function to be called at compile time
     with a string to be compiled as one argument
     and do side-effect to store data into memory
     and return a shorter string
     [this can be viewed as moving a cursor forward]
   * the compiler is a macro dispatcher
     it get next word and use predicates on word to do dispatch
** convention in assembly code
   * using underline to compose big word from small words
   * using "$" as prefix and postfix separator
   * indentation level = 3
   * naming convention of jo
     | convention   | jo type  |
     |--------------+----------|
     | prefix "V__" | variable |
     | prefix "M__" | macro    |
** convention in cicada-nymph code
   * using dash to compose big word from small words
   * using "," as prefix and postfix separator
   * indentation style = free
   * words are separated by space
     except for bar-ket
     every bar-ket is viewed as a word
** syntax of cicada-nymph
   | syntax          | semantic              |
   |-----------------+-----------------------|
   | borderfix "* *" | variable              |
   | borderfix "+ +" | [maybe used]          |
   | bar-ket ( )     |                       |
   | bar-ket [ ]     |                       |
   | bar-ket { }     | macro call            |
   |                 | (for macros of which  |
   |                 | the number of         |
   |                 | arguments is not fix) |
* -----------------------------------
* prolog
** include linux header
   #+begin_src fasm :tangle 1st-instar.fasm
   include "../include/linux-header.inc"
   #+end_src
** format header
   #+begin_src fasm :tangle 1st-instar.fasm
   format elf64 executable 3
   #+end_src
** entry
   #+begin_src fasm :tangle 1st-instar.fasm
   entry begin_to_interpret_threaded_code
   segment readable executable writeable
   #+end_src
* -----------------------------------
* macro in assembly code
** misc
   #+begin_src fasm :tangle 1st-instar.fasm
   ;; in fasm, "dup" is a reserved word
   dup equ duplicate
   #+end_src
** bead_size
   * 64-bits
   #+begin_src fasm :tangle 1st-instar.fasm
   bead_size = 8 ;; (byte)
   xx equ dq
   #+end_src
** argument_stack & return_stack
   * when doing "push"
     a stack-pointer moves to lower address
   * note that another style is that
     when doing "push"
     a stack-pointer moves to higher address
   * the stack-pointer
     always stores the address of current-free-address of the stack
   * note that another style is that
     under the stack-pointer
     there always stores the value of the-top-of-the-stack
   #+begin_src fasm :tangle 1st-instar.fasm
   ;; if you want to extend cicada in assembly,
   ;; the following registers must not be used
   ;; =================================
   define pointer$argument_stack   r15
   define pointer$return_stack     r14
   ;; =================================

   macro push_argument_stack register {
      mov [pointer$argument_stack], register
      add pointer$argument_stack, bead_size
      }
   macro pop_argument_stack register {
      sub pointer$argument_stack, bead_size
      mov register, [pointer$argument_stack]
      }

   macro push_return_stack register {
      mov [pointer$return_stack], register
      add pointer$return_stack, bead_size
      }
   macro pop_return_stack register {
      sub pointer$return_stack, bead_size
      mov register, [pointer$return_stack]
      }
   #+end_src
** memory allocation in un_initialized_memory
   * implemented as a memory map
   #+begin_src fasm :tangle 1st-instar.fasm
   current_free_address$un_initialized_memory = address$un_initialized_memory

   labeling  equ = current_free_address$un_initialized_memory
   preserve  equ current_free_address$un_initialized_memory = current_free_address$un_initialized_memory +
   #+end_src
** current_free_address$primitive_string_heap
   #+begin_src fasm :tangle 1st-instar.fasm
   current_free_address$primitive_string_heap = address$primitive_string_heap
   #+end_src
** exit
   #+begin_src fasm :tangle 1st-instar.fasm
   exit = 0
   #+end_src
** next
   #+begin_src fasm :tangle 1st-instar.fasm
   macro next {
      ;; 1. 移動 return_stack 中的第一串珠珠一次
      ;; 2. 如果 遇到珠珠的末尾
      ;;         把這串珠珠抽出
      ;;    否則 不抽出
      ;; 3. 去尋求被移出的一顆珠的意義
   local at_the_end_of_jojo
      pop_return_stack rbx
      mov rax, qword[rbx] ;; 記錄被移出的一顆珠
      add rbx, bead_size
      cmp dword[rbx], exit
      je at_the_end_of_jojo
      push_return_stack rbx ;; 把珠珠放回 就代表不抽出
   at_the_end_of_jojo:
      ;; 去尋求被移出的一顆珠的意義
      ;; 因爲 對其意義的詮釋方式 被記錄在其地址下
      ;; 所以需要一次 間接跳
      jmp qword[rax]
      ;; 跳過去之後 rax 保存的是被移出的一顆珠
      ;; rax 可能被作爲 bead explainer 的參數
      }
   #+end_src
** link
   #+begin_src fasm :tangle 1st-instar.fasm
   ;; initial link to point to 0 (as null)
   link = 0
   #+end_src
** make_name_string
   * 2 bytes for length of name_string
   * note that
     the following is using local label
   #+begin_src fasm :tangle 1st-instar.fasm
   macro make_name_string string {

   virtual at 0
   .start$string:
      db string
   .end$string:
      dd (.end$string - .start$string)
      load .length word from (.end$string)
   end virtual
   store word .length at (current_free_address$primitive_string_heap)

   current_free_address$primitive_string_heap = current_free_address$primitive_string_heap + 2

   repeat .length
      virtual at 0
         db string
         load .char byte from (% - 1)
      end virtual
      store byte .char at (current_free_address$primitive_string_heap)
      current_free_address$primitive_string_heap = current_free_address$primitive_string_heap + 1
   end repeat

   }
   #+end_src
** define_function
   #+begin_src fasm :tangle 1st-instar.fasm
   macro define_function string, jo {

   define_function__#jo:

   name__#jo:
      xx current_free_address$primitive_string_heap

      make_name_string string

   link__#jo:
      xx link
      link = link__#jo

   jo:
      xx explain$function

      ;; 後面跟着作爲 function 的函數體的一串珠珠

      }
   #+end_src
** define_macro
   #+begin_src fasm :tangle 1st-instar.fasm
   macro define_macro string, jo {

   define_macro__#jo:

   name__#jo:
      xx current_free_address$primitive_string_heap

      make_name_string string

   link__#jo:
      xx link
      link = link__#jo

   jo:
      xx explain$macro

      ;; 後面跟着作爲 macro (特殊的 function) 的函數體的一串珠珠

      }
   #+end_src
** define_primitive_function
   #+begin_src fasm :tangle 1st-instar.fasm
   macro define_primitive_function string, jo {

   define_primitive_function__#jo:

   name__#jo:
      xx current_free_address$primitive_string_heap

      make_name_string string

   link__#jo:
      xx link
      link = link__#jo

   jo:
      xx assembly_code__#jo

   assembly_code__#jo:
      ;; 後面跟着作爲 primitive_function 的函數體的匯編代碼

      }
   #+end_src
** define_variable
   * no constant
     only variable
   * when a variable jo in the jojo
     it push the value of the variable to argument_stack
   * when wish to change a variable's value
     use key_word "address" to get the address of the variable
   #+begin_src fasm :tangle 1st-instar.fasm
   macro define_variable string, jo {

   define_variable__#jo:

   name__#jo:
      xx current_free_address$primitive_string_heap

      make_name_string string

   link__#jo:
      xx link
      link = link__#jo

   jo:
      xx explain$variable

      ;; 後面跟着作爲 全局變元之值的 bead_size 大小的數值
      ;; 只能有一個值

      }
   #+end_src
* -----------------------------------
* primitive_string_heap
  #+begin_src fasm :tangle 1st-instar.fasm
  size$primitive_string_heap = 100 * 1024 ;; (byte)

  address$primitive_string_heap:
     times size$primitive_string_heap db 0
  #+end_src
* jo
** note
   * 注意
     每次經由 next 間接跳
     到這裏的詮釋者的時候
     rax 都保存着珠的值
     所以 rax 這個寄存器會被作爲某些詮釋者的參數
   * 每個 jo 的類型對應一種解釋方式
** note primitive function
   * a primitive function explains itself
** explain$function
   * 把由這個 function 類型的 珠
     所找到的 一串珠珠 入 return_stack
   * a jojo can not be of size 0 or 1
   * use rax as an argument
     which stores a jo
   #+begin_src fasm :tangle 1st-instar.fasm
   explain$function:
      add rax, bead_size
      push_return_stack rax
      next
   #+end_src
** explain$macro
   * the same as explain$function
     we need to redefine it
     for the value of explainer
     is used to decide the type of the jo
   #+begin_src fasm :tangle 1st-instar.fasm
   explain$macro:
      add rax, bead_size
      push_return_stack rax
      next
   #+end_src
** explain$variable
   #+begin_src fasm :tangle 1st-instar.fasm
   explain$variable:
      add rax, bead_size
      mov rbx, [rax]
      push_argument_stack rbx
      next
   #+end_src
* begin_to_interpret_threaded_code
  #+begin_src fasm :tangle 1st-instar.fasm
  begin_to_interpret_threaded_code:

     cld ;; set DF = 0, then rsi and rdi are incremented

     mov pointer$argument_stack,  address$argument_stack
     mov pointer$return_stack,    address$return_stack

     mov rax, first_jojo
     push_return_stack rax
     next

  first_jojo:
     xx little_test
  #+end_src
* argument_stack
** memory allocation
   #+begin_src fasm :tangle 1st-instar.fasm
   address$argument_stack labeling
      preserve 1024 * 1024 * bead_size
   #+end_src
* return_stack
** memory allocation
   #+begin_src fasm :tangle 1st-instar.fasm
   address$return_stack labeling
      preserve 1024 * 1024 * bead_size
   #+end_src
* special primitive function
** note
   * special primitive function do special side-effect on return_stack
   * the naming convention in assembly code
     of special primitive function
     is the same as it of jo
   * the name of a special primitive function
     is not exported to cicada-language as a function
     but as a variable
   * the name of a special primitive function in assembly code
     maybe reused as a macro word in cicada-language
     but the name of the macro in assembly code
     is prefixed by "M__"
** literal
   #+begin_src fasm :tangle 1st-instar.fasm
   define_variable "*literal*", V__literal
      xx literal

   define_primitive_function "", literal
      ;; (* -- fixnum *)
      ;; 如果在一串珠珠末尾
      ;;     就抽出這串珠珠
      pop_return_stack rbx
      mov  rax, [rbx]
      push_argument_stack rax
      add  rbx, bead_size
      mov  rax, [rbx]
      test rax, rax
      jz .meet_end
      push_return_stack rbx
   .meet_end:
      ;; 不放回 就算抽出
      next
   #+end_src
** address
   #+begin_src fasm :tangle 1st-instar.fasm
   define_variable "*address*", V__address
      xx address

   define_primitive_function "", address

      next
   #+end_src
** branch
** false?branch
* bool
** note predicate
   * predicates do NOT consume their arguments in argument_stack
     instead they push a bool into argument_stack
* fixnum
* memory
* macro in cicada-nymph
* little_test
  #+begin_src fasm :tangle 1st-instar.fasm
  define_function "little_test", little_test
     xx literal, 4
     xx exit_with_TOS

     ;; xx V__little_test_number
     ;; xx exit_with_TOS


  define_variable "", V__little_test_number
     xx 3

  define_primitive_function "", exit_with_TOS
     pop_argument_stack sys_1_rdi
     mov sys_n_rax, syscall_exit
     syscall
  #+end_src
* -----------------------------------
* epilog
** un_initialized_memory
   #+begin_src fasm :tangle 1st-instar.fasm
   size$un_initialized_memory = 64 * 1024 * 1024 ;; (byte)

   segment readable writeable
   address$un_initialized_memory:
      rb size$un_initialized_memory
   #+end_src
* ===================================
